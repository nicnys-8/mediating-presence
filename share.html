
<!-- Partly based on example from http://learningwebgl.com/lessons/lesson02/index.html -->

<html>
    <head>
        
        <title>Point Cloud Rendering Test</title>
        
		<script type="text/javascript" src="js/tab-control.js"></script>
		<script type="text/javascript" src="js/popup-manager.js"></script>
		
        <script type="text/javascript" src="js/mediaext.js"></script>
        <script type="text/javascript" src="js/lib/webgl-utils.js"></script>
        <script type="text/javascript" src="js/lib/glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="js/model-controller.js"></script>
        <script type="text/javascript" src="js/point-cloud-renderer.js"></script>
		<script type="text/javascript" src="js/phong-renderer.js"></script>
		<script type="text/javascript" src="js/phong-renderer-ext.js"></script>
		<script type="text/javascript" src="js/rgba-mesh-renderer.js"></script>
		<script type="text/javascript" src="js/ply-parser.js"></script>
		
        <link rel="stylesheet" type="text/css" href="css/pb.css"/>
        <link rel="stylesheet" type="text/css" href="css/pointcloud.css"/>
		
        <script type="text/javascript">
			
			var glCanvas,
				renderer,
				controller,
				model,
				shareButton,
				clearButton,
				sendRotTimer = null,
				resumeSend = false,
				invitePopup,
				uniforms = {
					specular : [0.8, 0.8, 0.8],
					diffuse : [0.6, 0.6, 0.6],
					ambient : [0.2, 0.2, 0.2],
					shininess : 20.0,
					lightPos : [0, 0, 0],
					zoom : 1.0,
					blobbiness : 0.0,
					setValue : function(name, value) {
						this[name] = value;
					},
					setElement : function(name, index, value) {
						this[name][index] = value;
					},
				};
			
			TabControl.onLoad = function() {
                
				var onResize = function() {
					if (glCanvas) {
						glCanvas.width = glCanvas.offsetWidth;
						glCanvas.height = glCanvas.offsetHeight;
					}
				};
				onResize();
				window.addEventListener("resize", onResize, false);
				
				// Initialize the control panel for material properties
				document.getElementById("specularColor").onchange = function() {
					ColorConvert.hexToRGB(this.value, uniforms.specular);
					updateInputs("specular");
				};
				document.getElementById("diffuseColor").onchange = function() {
					ColorConvert.hexToRGB(this.value, uniforms.diffuse);
					updateInputs("diffuse");
				};
				document.getElementById("ambientColor").onchange = function() {
					ColorConvert.hexToRGB(this.value, uniforms.ambient);
					updateInputs("ambient");
				};
				document.getElementById("shininess").value = uniforms.shininess;
				
				updateInputs("specular");
				updateInputs("diffuse");
				updateInputs("ambient");
				
				shareButton = document.getElementById("shareButton");
				clearButton = document.getElementById("clearButton");
				
				// **********************
                // Drag and drop with File API
                var dropbox = document.getElementById("dropbox"),
					state = document.getElementById("status");
                
                if (typeof window.FileReader === "undefined") {
                    state.className = "fail";
                    state.innerHTML = "File API unavailable, change browser!!!! :)";
                } else {
                    state.className = "success";
                }
                
                dropbox.ondragenter = function () { dropbox.className = "hover"; return false; };
                dropbox.ondragleave = function () { dropbox.className = ""; return false; };
                dropbox.ondragover = function () { dropbox.className = "hover"; return false; };
                dropbox.ondragend = function () { return false; };
                dropbox.ondrop = function (e) {
                    dropbox.className = "";
                    e.preventDefault();
                    readFiles(e.dataTransfer.files);
                    return false;
                };
                // **********************
                
                document.getElementById("fileSelect").addEventListener("change",
																	   function () { readFiles(this.files); },
																	   false);
				
				invitePopup = PopupManager.createPopup("Someone wants to share a 3D model with you!",
													   "images/share-icon.png",
													   {text:"Accept", func:acceptShared3DModel},
													   {text:"Decline", func:declineShared3DModel});
            };
			
			TabControl.onActivate = function() {
				requestAnimFrame(drawScene);
				
				if (resumeSend) {
					sendRotation();
				}
			};
			
			TabControl.onDeactivate = function() {
				cancelAnimFrame(drawScene);
				if (sendRotTimer) {
					clearTimeout(sendRotTimer);
					resumeSend = true;
					sendRotTimer = null;
				}
			};
			
			TabControl.onStreamAdded = function(stream) {};
			TabControl.onStreamRemoved = function(stream) {};
			
			TabControl.onMessageReceived = function(senderId, type, data) {
				
				switch (type) {
					case "rotate":
						if (controller) {
							controller.updateRotation(data.rot);
						}
						break;
					case "invite":
						PopupManager.showPopup(invitePopup);
						break;
					case "inviteAccepted":
						onShareAccepted();
						break;
					case "inviteDeclined":
						onShareDeclined();
						break;
					case "model":
						displayModel(data);
						sendRotation();
						TabControl.sendMessage("share", "modelReceived", {});
						break;
					case "modelReceived":
						console.log("Received model load confirmation");
						sendRotation();
						break;
				}
			};
			
			TabControl.onKinectInit = function(proxy) {};
			TabControl.onNewKinectData = function(videoData, depthData) {};
            
			/**
			 Sends an invitation to remote users to 
			 share the currently displayed 3D model
			 */
			function sendShareInvite() {
				TabControl.sendMessage("share", "invite", {/*thumbnail of the 3D model, name of the file, ...*/});
				shareButton.disabled = true;
			}
			
			/**
			 Called when remote user accepts the client's 
			 invititation to share a model
			 */
			function onShareAccepted() {
				if (model) {
					console.log("Sending model");
					console.log(model);
					
					// Send the model
					TabControl.sendMessage("share", "model", serializeModel(model));
					
					console.log("Waiting for confirmation...");
				}
			}
			
			/**
			 Called when remote user declines the client's 
			 invititation to share a model
			 */
			function onShareDeclined() {
				// TODO: display message
				clearTimeout(sendRotTimer);
				sendRotTimer = null;
				shareButton.disabled = false;
			}
			
			/**
			 Invite popup callback, accepts share invite from remote user
			 */
			function acceptShared3DModel() {
				// TODO: switchToTab("#share");
				TabControl.sendMessage("share", "inviteAccepted", {});
			}
			
			/**
			 Invite popup callback, declines share invite from remote user
			 */
			function declineShared3DModel() {
				TabControl.sendMessage("share", "inviteDeclined", {});
			}
			
			/**
			 Send rotation increment, if any (for shared model viewing)
			 */
			function sendRotation() {
				var sendRot = controller.getSendRotation();
				if (sendRot) {
					TabControl.sendMessage("share", "rotate", {rot:sendRot});
				}
				setTimeout(sendRotation, 100);
			}
			
			/**
			 Creates a FileReader and tries to parse a 3D model
			 from the first file in @param files
			 */
            function readFiles(files) {
                
                var file = files[0];
                
                var splitName = file.name.split(".");
                if (splitName.length < 2 || splitName[1] !== "ply") {
                    alert("I ONLY ACCEPT .ply FILES! ." + splitName[1] + " FILES ANGER ME! >:(");
                    return;
                }
                
                var progress = document.getElementById("progressBar"),
					dropbox = document.getElementById("dropbox"),
					reader = new FileReader();
				
                reader.onerror = function(e) {
					var error = e.target.error;
					switch (error.code) {
						case error.NOT_FOUND_ERR:
							alert("File Not Found!");
							break;
						case error.NOT_READABLE_ERR:
							alert("File is not readable");
							break;
						case error.ABORT_ERR:
							break;
						default:
							alert("An error occurred reading this file.");
							break;
					};
				};
				
                reader.onprogress = function(e) {
					// e is a ProgressEvent
					if (e.lengthComputable) {
						var percentLoaded = Math.round((e.loaded / e.total) * 100);
						// Increase the progress bar length.
						progress.value = percentLoaded;
					}
				};
                
				reader.onabort = function(e) {
                    alert("File read cancelled");
                };
                
				reader.onloadstart = function(e) {
					progress.value = 0;
                    progress.className = "loading";
                };
                
				reader.onload = function (e) {
                    // Ensure that the progress bar displays 100% at the end.
                    progress.value = 100;
                    
					var result;
					
					try {
						result = Ply.parse(e.target.result);
						// console.log(result);
					} catch (error) {
						alert("Error parsing model. " + error);
						return;
					}
					
					setTimeout(function() {
								progress.className = "";
								displayModel(result);
							   }, 0);
                };
				
                // console.log('Reading file:');
                // console.log(file);
				reader.readAsArrayBuffer(file); // .readAsDataURL.readAsText
            }
			
			/**
			 Updates control panel inputs (to keep things in sync).
			 */
			function updateInputs(name) {
				var values = uniforms[name];
				document.getElementById(name + "Color").value = ColorConvert.RGBToHex(values);
				document.getElementById(name + "0").value = values[0];
				document.getElementById(name + "1").value = values[1];
				document.getElementById(name + "2").value = values[2];
			}
			
			/**
			 Creates a version of the model that can be sent as JSON
			 */
			function serializeModel(aModel) {
				
				var result = {};

				var copyArray = function(src) {
					if (typeof src == "Array") {
						return src;
					}
					if (src && src.length) {
						var len = src.length;
						var cpy = new Array(len);
						for (var i = 0; i < len; ++i) {
							cpy[i] = src[i];
						}
						return cpy;
					}
					// return undefined;
				}
				
				result.pos = copyArray(aModel.pos);
				result.normals = copyArray(aModel.normals);
				result.colors = copyArray(aModel.colors);
				result.faces = copyArray(aModel.faces);
				
				return result;
			}
			
			/**
			 Creates a WebGL canvas and a controller and displays the model
			 */
			function displayModel(aModel) {
				
				clearGLCanvas();
				
				// Create the WebGL canvas
				glCanvas = document.createElement("canvas");
				glCanvas.className = "gl-canvas";
				document.getElementById("container").appendChild(glCanvas);
				
				// Set size of canvas (to allocate framebuffer memory)
				glCanvas.width = glCanvas.offsetWidth;
				glCanvas.height = glCanvas.offsetHeight;
				
				// Select renderer
				if (aModel.pos) {
					if (!aModel.faces) {
						// No faces means it's a point cloud
						if (aModel.colors) {
							renderer = new PointCloudRenderer(glCanvas);
							renderer.bufferData(aModel.pos, aModel.colors);
						}
					} else {
						if (aModel.normals) {
							renderer = new PhongRendererExt(glCanvas);
							renderer.bufferData(aModel.pos, aModel.normals, aModel.faces);
						} else if (aModel.colors) {
							renderer = new MeshRenderer(glCanvas);
							renderer.bufferData(aModel.pos, aModel.colors, aModel.faces);
						}
					}
				}
				
				if (renderer) {
					
					model = aModel;
					
					// Create a controller for the models
					controller = new ModelController(glCanvas);
					controller.calculateInitalTransform(aModel.pos);
					
					dropbox.style.display = "none";
					shareButton.disabled = false;
					clearButton.disabled = false;
				
				} else {
					// No suitable renderer found, clear canvas
					// TODO: Alert or something?
					clearGLCanvas();
				}
			}
			
			/**
			 Removes the WebGL canvas and (tries?) to free GPU memory
			 */
			function clearGLCanvas() {
				
				// Destroy the renderer
				if (renderer) {
					renderer.destroy();
					renderer = null;
					model = null;
				}
				
				// Destroy the controller
				if (controller) {
					controller.destroy();
					controller = null;
				}
				
				// Remove the canvas
				if (glCanvas) {
					glCanvas.parentNode.removeChild(glCanvas);
					glCanvas = null;
				}
				
				dropbox.style.display = "block";
				
				clearButton.disabled = true;
				shareButton.disabled = true;
			}
			
			/**
			 Sets shader uniforms and renders the model
			 */
			function drawScene() {
				
				requestAnimFrame(drawScene);
				
				if (renderer) {
					
					if (renderer.setSpecular) {
						renderer.setSpecular(uniforms.specular);
						renderer.setDiffuse(uniforms.diffuse);
						renderer.setAmbient(uniforms.ambient);
						renderer.setShininess(uniforms.shininess);
						renderer.setLightPos(uniforms.lightPos);
						renderer.setZoom(uniforms.zoom);
						renderer.setBlobbiness(uniforms.blobbiness);
					}
					
					controller.setZoom(uniforms.zoom);
					var mvMatrix = controller.getModelViewMatrix();
					renderer.setModelViewMatrix(mvMatrix);
					renderer.render();
				}
			}
			
			/**
			 Functions for converting colors between hex and [rgb]
			 */
			var ColorConvert = function() {
				
				const haxHex = "0123456789abcdef", maskUpper = 0xf0, maskLower = 0x0f;
				var API = {};
				
				API.hexToRGB = function(value, dst) {
				
					var R = ((haxHex.indexOf(value[1])) << 4 | haxHex.indexOf(value[2])) / 255.0,
						G = ((haxHex.indexOf(value[3])) << 4 | haxHex.indexOf(value[4])) / 255.0,
						B = ((haxHex.indexOf(value[5])) << 4 | haxHex.indexOf(value[6])) / 255.0;
					
					if (!dst) {
						dst = [];
					}
				
					dst[0] = R;
					dst[1] = G;
					dst[2] = B;
				
					return dst;
				};
			
				API.RGBToHex = function(rgb) {
					var R, G, B, hex;
					R = Math.round(rgb[0] * 255);
					G = Math.round(rgb[1] * 255);
					B = Math.round(rgb[2] * 255);
					hex = "#" + haxHex[(R & maskUpper) >> 4] + haxHex[R & maskLower] +
								haxHex[(G & maskUpper) >> 4] + haxHex[G & maskLower] +
								haxHex[(B & maskUpper) >> 4] + haxHex[B & maskLower];
					return hex;
				}
				
				return API;
			}();
			
            </script>
        
    </head>
	
	<body>
        
		<div id="sidebar-left">
			
			<div class="control-panel" id="controls-left">
				
				<h2>Material</h2>
				<h3>Specular <input id="specularColor" type="color"/></h3>
				<table>
					<tr>
						<td style="text-align:right;">Red</td>
						<td><input id="specular0" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('specular', 0, this.value); updateInputs('specular');"/></td>
					</tr><tr>
						<td style="text-align:right;">Green</td>
						<td><input id="specular1" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('specular', 1, this.value); updateInputs('specular');"/></td>
					</tr><tr>
						<td style="text-align:right;">Blue</td>
						<td><input id="specular2" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('specular', 2, this.value); updateInputs('specular');"/></td>
					</tr>
				</table>
				
				<h3>Diffuse <input id="diffuseColor" type="color"/></h3>
				<table>
					<tr>
						<td style="text-align:right;">Red</td>
						<td><input id="diffuse0" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('diffuse', 0, this.value); updateInputs('diffuse');"/></td>
					</tr><tr>
						<td style="text-align:right;">Green</td>
						<td><input id="diffuse1" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('diffuse', 1, this.value); updateInputs('diffuse');"/></td>
					</tr><tr>
						<td style="text-align:right;">Blue</td>
						<td><input id="diffuse2" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('diffuse', 2, this.value); updateInputs('diffuse');"/></td>
					</tr>
				</table>
				
				<h3>Ambient <input id="ambientColor" type="color"/></h3>
				<table>
					<tr>
						<td style="text-align:right;">Red</td>
						<td><input id="ambient0" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('ambient', 0, this.value); updateInputs('ambient');"/></td>
					</tr><tr>
						<td style="text-align:right;">Green</td>
						<td><input id="ambient1" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('ambient', 1, this.value); updateInputs('ambient');"/></td>
					</tr><tr>
						<td style="text-align:right;">Blue</td>
						<td><input id="ambient2" type="range" min=0 max=1 step=0.004
							onchange="uniforms.setElement('ambient', 2, this.value); updateInputs('ambient');"/></td>
					</tr>
				</table>
				
				<h3>Shininess</h3>
				<input id="shininess" type="range" min=0 max=255 value=127
					onchange="uniforms.setValue('shininess', this.value);"/><br>
				
				<h3>Zoom</h3>
				<input type="range" min=0 max=2 value=1 step=0.01
					onchange="uniforms.setValue('zoom', this.value);"/><br>
			</div>
			
		</div>
		
		<div id="content">
			
			<h1>Share 3D models</h1>
			
			<div id="container">
				<div id="dropbox">
					<p id="status">Drop a .ply file here, or use this fine button:<input type="file" id="fileSelect"></p>
					<progress id="progressBar" value=0 max=100></progress>
				</div>
			</div>
			
			<button id="shareButton" onclick="sendShareInvite();"
				style="padding:1em; margin:0em;" disabled=true>Share!</button>
			<button id="clearButton" onclick="clearGLCanvas();"
				style="padding:1em; margin:0em;" disabled=true>Clear</button>
		</div>
		
		<div id="sidebar-right">
			
			<div class="control-panel" id="controls-right">
				
				<h2>Light</h2>
				<h3>Position</h3>
				<table>
					<tr>
						<td style="text-align:right;">x</td>
						<td><input type="range" min=-5 max=5 value=0 step=0.05
							onchange="uniforms.setElement('lightPos', 0, this.value);"/></td>
					</tr><tr>
						<td style="text-align:right;">y</td>
						<td><input type="range" min=-5 max=5 value=0 step=0.05
							onchange="uniforms.setElement('lightPos', 1, this.value);"/></td>
					</tr><tr>
						<td style="text-align:right;">z</td>
						<td><input type="range" min=-5 max=5 value=0 step=0.05
							onchange="uniforms.setElement('lightPos', 2, this.value);"/></td>
					</tr>
				</table>
				<h3>BLOB!</h3>
				<input type="range" min=-0.125 max=0.125 value=0 step=0.00125
					onchange="uniforms.setValue('blobbiness', this.value);"/><br>
				</div>
				
			</div>
		
		</div>
        
	
	</body>
    
</html>