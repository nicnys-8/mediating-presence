
<!-- Partly based on example from http://learningwebgl.com/lessons/lesson02/index.html -->

<html>
    <head>
        
        <title>Point Cloud Rendering Test</title>
        
		<script type="text/javascript" src="js/tab-control.js"></script>
        <script type="text/javascript" src="js/mediaext.js"></script>
        <script type="text/javascript" src="js/lib/webgl-utils.js"></script>
        <script type="text/javascript" src="js/lib/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="js/point-cloud-renderer.js"></script>
		<script type="text/javascript" src="js/phong-renderer.js"></script>
		<script type="text/javascript" src="js/rgba-mesh-renderer.js"></script>
		
        <link rel="stylesheet" type="text/css" href="css/pb.css"/>
        <link rel="stylesheet" type="text/css" href="css/pointcloud.css"/>
        
        <script type="text/javascript">

            PlyParse = {};
            
			PlyParse.TYPE_SIZES = { // Some of these may not actually exist :)
				"char" : 1,
				"char8" : 1,
				"uchar" : 1,
				"uchar8" : 1,
				"short" : 2,
				"short16" : 2,
				"ushort" : 2,
				"ushort16" : 2,
				"int8" : 1,
				"uint8" : 1,
				"int16" : 2,
				"uint16" : 2,
				"int" : 4,
				"int32" : 4,
				"uint" : 4,
				"uint32" : 4,
				"float" : 4,
				"float32" : 4,
				"float64" : 8,
				"double" : 8,
				"double64" : 8,
			};
			
			PlyParse.ASCII_PARSE_FUNCS = { // Some of these may not actually exist :)
				"char" : parseInt,
				"char8" : parseInt,
				"uchar" : parseInt,
				"uchar8" : parseInt,
				"short" : parseInt,
				"short16" : parseInt,
				"ushort" : parseInt,
				"ushort16" : parseInt,
				"int8" : parseInt,
				"uint8" : parseInt,
				"int16" : parseInt,
				"uint16" : parseInt,
				"int" : parseInt,
				"int32" : parseInt,
				"uint" : parseInt,
				"uint32" : parseInt,
				"float" : parseFloat,
				"float32" : parseFloat,
				"float64" : parseFloat,
				"double" : parseFloat,
				"double64" : parseFloat,
			};
			PlyParse.ARRAY_TYPES = { // Some of these may not actually exist :)
				"char" : Int8Array,
				"char8" : Int8Array,
				"uchar" : Uint8Array,
				"uchar8" : Uint8Array,
				"short" : Int16Array,
				"short16" : Int16Array,
				"ushort" : Uint16Array,
				"ushort16" : Uint16Array,
				"int8" : Int8Array,
				"uint8" : Uint8Array,
				"int16" : Int16Array,
				"uint16" : Uint16Array,
				"int" : Int32Array,
				"int32" : Int32Array,
				"uint" : Uint32Array,
				"uint32" : Uint32Array,
				"float" : Float32Array,
				"float32" : Float32Array,
				"float64" : Float64Array,
				"double" : Float64Array,
				"double64" : Float64Array,
			};
			
			PlyProps = function(format, numVertices, numFaces, vertexProps, faceProps) {
				
				this.format = format;
				this.numVertices = numVertices;
				this.numFaces = numFaces;
				this.faceProps = faceProps;
				
				var offset = 0;
				var vertexPropsExt = {};
				for (var i in vertexProps) {
					
					var name = vertexProps[i].name;
					var type = vertexProps[i].type;
					var size = PlyParse.TYPE_SIZES[type];
					
					vertexPropsExt[name] = {
						index:i,
						size:size,
						offset:offset,
						parseFunc:PlyParse.ASCII_PARSE_FUNCS[type],
						type:type,
					};
					
					offset += size;
				}
				this.vertexProps = vertexPropsExt;
			};
			
			PlyProps.prototype.hasProperty = function(name) {
				return !!this.vertexProps[name];
			};
			
			PlyProps.prototype.hasProperties = function(names) {
				for (var i in names) {
					if (!this.hasProperty(names[i]))
						return false;
				}
				return true;
			};
            
			PlyProps.prototype.vertexPropsLength = function() {
				var len = 0;
				for (var i in this.vertexProps) {
					len += this.vertexProps[i].size;
				}
				return len;
			}
			
			PlyParse.parseHeader = function(header) {
				
				var numVertices = 0,
					numFaces = 0,
					format;
				
				console.log(header);
				
				var lines = header.split("\n");
				
				for (var i in lines) {
					lines[i] = lines[i].trim();
				}
				
				// Check for magic word at start of file!
				if (lines[0] != "ply") {
					alert("Fool! This is no .ply file!");
					return;
				}
				
				// The format is specified on the second line
				format = lines[1].substring(7);
				
				// Remove comments
				for (var i in lines) {
					if (lines[i].substring(0, 8) == "comment") {
						lines.splice(i, 1);
					}
				}
				if (lines[lines.length - 1] == "end_header") {
					lines.splice(lines.length - 1, 1);
				}
				header = lines.join("\n");

				// Extract number of vertices
				var verts = header.split("element vertex ");
				if (verts.length > 1) {
					numVertices = parseInt(verts[1]);
				}
				
				// Extract vertex properties
				var propsList = header
					.split("element vertex " + numVertices)[1]
					.split("element face")[0]
					.trim()
					.split("property ");
				
				// Make a list of all properties
				var vertexProps = [];
				for (var i = 0; i < propsList.length; i++) {
					var prop = propsList[i];
					if (propsList[i] == "") {
						continue;
					}
					var typeAndName = prop.trim().split(" ");
					vertexProps.push({type:typeAndName[0], name:typeAndName[1]});
				}
				
				// Extract number of faces
				var faceProps = { countType:"", indexType:"" };
				var faces = header.split("element face ");
				if (faces.length > 1) {
					numFaces = parseInt(faces[1]);
					
					// Extract face property list types
					// Assumes element face .. is followed by property list
					var facePropsList = faces[1].split("property list ")[1].split(" ");
					faceProps.countType = facePropsList[0];
					faceProps.indexType = facePropsList[1];
				}
				
				return new PlyProps(format, numVertices, numFaces, vertexProps, faceProps);
			};
			
			PlyParse.parse = function(inputStr) {
			
				var data = new Uint8Array(inputStr);
				var header = "";
				
				var index = 0;
				var len = data.length;
				var foundHeader = false;
				
				while (index < len) {
					header += String.fromCharCode(data[index++]);
					
					if (index > 10 && header.substring(index - 10) == "end_header") {
						index++; // Skip last whitespace
						foundEndOfHeader = true;
						break;
					}
				}
				
				if (!foundEndOfHeader) {
					throw "Invalid file format ('end_header' missing)";
				}
				
				// var split = inputStr.split("end_header");
				
				var info = PlyParse.parseHeader(header);
				
				console.log(info);
				
				var dataString = "";
				var splitData;
				var result = {};
				
				switch (info.format) {
					case "ascii 1.0":
					
						// Convert the ArrayBuffer bytes to ascii (assuming UTF-8 encoding)
						
						var dataString = new Array(inputStr.byteLength - index);
						
						for (var i = index, len = inputStr.byteLength; i < len; ++i) {
							dataString[i] = String.fromCharCode(data[i]);
						}
						console.log(dataString.length);
					
						// Split the data into lines and words
						splitData = dataString.join("").split("\n");
						console.log(splitData.length);
					
						for (var i = 0, len = splitData.length; i < len; ++i) {
							splitData[i] = splitData[i].split(" ");
						}
					
						result.pos = PlyParse.asciiParseVertexProps(splitData, ["x", "y", "z"], info);
						result.normals = PlyParse.asciiParseVertexProps(splitData, ["nx", "ny", "nz"], info);
						result.colors = PlyParse.asciiParseVertexProps(splitData, ["red", "green", "blue"], info);
						result.intensity = PlyParse.asciiParseVertexProps(splitData, ["intensity"], info);
						result.faces = PlyParse.asciiParseElements(splitData, info.numVertices, info);
					
						break;
					
					case "binary_little_endian 1.0":

						var firstVertex = index;
						var firstElem = index + info.vertexPropsLength() * info.numVertices;
						
						result.pos = PlyParse.binaryParseVertexProps(data, firstVertex, ["x", "y", "z"], info);
						result.normals = PlyParse.binaryParseVertexProps(data, firstVertex, ["nx", "ny", "nz"], info);
						result.colors = PlyParse.binaryParseVertexProps(data, firstVertex, ["red", "green", "blue"], info);
						result.intensity = PlyParse.binaryParseVertexProps(data, firstVertex, ["intensity"], info);
						result.faces = PlyParse.binaryParseElements(data, firstElem, info);
						break;
					
					case "binary_big_endian 1.0":
						throw "Sorry, we don't support big endian binary format yet...";
					default:
						throw "Invalid ply format '" + info.format + "'.";
				}
				// *************************
				
				// Suggest a renderer for the model
				result.renderer = null;
				if (result.pos) {
					if (!result.faces) {
						// No faces means it's a point cloud
						if (result.colors) {
							result.renderer = PointCloudRenderer;
						}
					} else {
						if (result.normals) {
							result.renderer = PhongRenderer;
						} else if (result.colors || result.intensity) {
							result.renderer = MeshRenderer;
						}
					}
				}
				
				// A little haxxing here, since my renderers
				// expect RGBA data as normalized 32-bit floats
				if (result.colors && info.vertexProps["red"].size == 1) {
					var rgba = new Array(Math.round(result.colors.length / 3 * 4));
					var indexIn = 0, indexOut = 0;
					var norm = 1.0 / 255.0;
					for (var i = 0; i < result.colors.length / 3; i++) {
						rgba[indexOut++] = result.colors[indexIn++] * norm;
						rgba[indexOut++] = result.colors[indexIn++] * norm;
						rgba[indexOut++] = result.colors[indexIn++] * norm;
						rgba[indexOut++] = 1.0;
					}
					result.colors = new Float32Array(rgba);
					
				} else if (result.intensity) {
					var rgba = new Array(result.intensity.length * 4);
					var indexOut = 0;
					for (var i = 0; i < result.intensity.length; i++) {
						var intensity = result.intensity[i];
						rgba[indexOut++] = intensity;
						rgba[indexOut++] = intensity;
						rgba[indexOut++] = intensity;
						rgba[indexOut++] = 1.0;
					}
					result.colors = new Float32Array(rgba);
				}
				
				return result;
            };
							
			PlyParse.asciiParseVertexProps = function(splitData, propNames, info) {
				
				var count = info.numVertices;
				
				if (count == 0) {
					return null;
				}
				
				var indices = [];
				var parseFuncs = [];
				var numProps = propNames.length;
				
				// Check if properties exist
				if (!info.hasProperties(propNames)) {
					console.log("Trying to parse missing properties " + propNames);
					return null;
				}
				
				for (var i = 0; i < numProps; i++) {
					var prop = info.vertexProps[propNames[i]];
					indices[i] = prop.index;
					parseFuncs[i] = prop.parseFunc;
				}
				
				// var lines = data.split("\n");
				var result = new Array(count * numProps);
				var index = 0;
				for (var i = 0; i < count; i++) {
					var line = splitData[i];
					for (var j = 0; j < numProps; j++) {
						result[index++] = parseFuncs[j](line[indices[j]]);
					}
				}
				
				var arrayType = PlyParse.ARRAY_TYPES[info.vertexProps[propNames[0]].type];
				
				return new arrayType(result);
			}
				
			PlyParse.asciiParseElements = function(splitData, startIndex, info) {
					
				var count = info.numFaces;
				
				if (count == 0) {
					return null;
				}
				
				var result = new Array(count * 3);
				var index = 0;
				var maxIndex = Math.pow(2, 16);
				
				for (var i = 0; i < count; i++) {
					var line = splitData[startIndex + i];
					
					var indexCount = parseInt(line[0]);
					if (indexCount == 3) {
						
						var i1 = parseInt(line[1]);
						var i2 = parseInt(line[2]);
						var i3 = parseInt(line[3]);
						
						if (i1 < maxIndex && i2 < maxIndex && i3 < maxIndex) {
							result[index++] = i1;
							result[index++] = i2;
							result[index++] = i3;
						}
					}
				}
					
				return new Uint16Array(result);
			}
				
			PlyParse.binaryParseVertexProps = function(data, startIndex, propNames, info) {
				
				var count = info.numVertices;
				
				if (count == 0) {
					return null;
				}
				
				var offsets = [];
				var numProps = propNames.length;
				
				// Check if properties exist
				if (!info.hasProperties(propNames)) {
					console.log("Trying to parse missing properties " + propNames);
					return null;
				}
				
				// Check that all properties are of the same type
				var type = info.vertexProps[propNames[0]].type;
				for (var i = 1; i < numProps; i++) {
					var otherType = info.vertexProps[propNames[i]].type;
					if (type !== otherType) {
						console.log("Property size mismatch in binary data, '" + type + "' and '" + otherType + "'.");
						return null;
					}
				}
				
				// Make offset list
				for (var i = 0; i < numProps; i++) {
					var prop = info.vertexProps[propNames[i]];
					offsets[i] = prop.offset;
				}
				
				var size = PlyParse.TYPE_SIZES[type];
				var result = new ArrayBuffer(count * numProps * size);
				var lineLength = info.vertexPropsLength();
				var buffer;
				var indexIn = startIndex;
				var indexOut = 0;
				
				// PARSE!
				switch (size) {
					case 1:
						buffer = new Uint8Array(result);
						for (var i = 0; i < count; i++) {
							for (var j = 0; j < numProps; j++) {
								buffer[indexOut++] = data[indexIn + offsets[j]];
							}
							indexIn += lineLength;
						}
						break;
					case 2:
						buffer = new Uint16Array(result);
						for (var i = 0; i < count; i++) {
							for (var j = 0; j < numProps; j++) {
								var k = indexIn + offsets[j];
								buffer[indexOut++] = data[k] | (data[k + 1] << 8);
							}
							indexIn += lineLength;
						}
						break;
					case 4:
						buffer = new Uint32Array(result);
						for (var i = 0; i < count; i++) {
							for (var j = 0; j < numProps; j++) {
								var k = indexIn + offsets[j];
								buffer[indexOut++] = data[k] | (data[k + 1] << 8) | (data[k + 2] << 16) | (data[k + 3] << 24);
							}
							indexIn += lineLength;
						}
						break;
					case 8:
						console.log("Parsing doubles not supported yet..!");
						return null;
					default:
						return null;
				}
				
				var arrayType = PlyParse.ARRAY_TYPES[type];
				
				return new arrayType(result);
			}

			PlyParse.binaryParseElements = function(data, startIndex, info) {
				
				var count = info.numFaces;
				
				if (count == 0) {
					return null;
				}
				
				// size1 isn't used, assuming 8 bit data type
				var size1 = PlyParse.TYPE_SIZES[info.faceProps.countType];
				var size2 = PlyParse.TYPE_SIZES[info.faceProps.indexType];
				
				var indexIn = startIndex;
				var indexOut = 0;
				var result = new ArrayBuffer(3 * size2 * count);
				var buffer;
				
				switch (size2) {
					case 1:
						buffer = new Uint8Array(result);
						for (var i = 0; i < count; i++) {
							
							var indexCount = data[indexIn++];
							
							if (indexCount == 3) {
								buffer[indexOut++] = data[indexIn + 0];
								buffer[indexOut++] = data[indexIn + 1];
								buffer[indexOut++] = data[indexIn + 2];
							} else {
								console.log("Mesh face not triangle, skipping");
							}
							indexIn += indexCount;
						}
						break;
					case 2:
						buffer = new Uint16Array(result);
						for (var i = 0; i < count; i++) {
							
							var indexCount = data[indexIn++];
							
							if (indexCount == 3) {
								buffer[indexOut++] = data[indexIn + 0] | (data[indexIn + 1] << 8);
								buffer[indexOut++] = data[indexIn + 2] | (data[indexIn + 3] << 8);
								buffer[indexOut++] = data[indexIn + 4] | (data[indexIn + 5] << 8);
							} else {
								console.log("Mesh face not triangle, skipping");
							}
							indexIn += indexCount * 2;
						}
						
						break;
					case 4:
						buffer = new Uint16Array(result);
						for (var i = 0; i < count; i++) {
							
							var indexCount = data[indexIn++];
							
							if (indexCount == 3) {
								if ((data[indexIn + 2] | data[indexIn + 3] |
									 data[indexIn + 6] | data[indexIn + 7] |
									 data[indexIn + 10] | data[indexIn + 11]) > 0) {
									// Index is out of bounds, WebGL limits number of indexable vertices to 2^16 - 1 (index type unsigned short)
								} else {
									buffer[indexOut++] = data[indexIn + 0] | (data[indexIn + 1] << 8);
									buffer[indexOut++] = data[indexIn + 4] | (data[indexIn + 5] << 8);
									buffer[indexOut++] = data[indexIn + 8] | (data[indexIn + 9] << 8);
								}
							} else {
								console.log("Mesh face not triangle, skipping");
							}
							
							indexIn += indexCount * 4;
						}
						break;
					default:
						return null;
				}
				
				var arrayType;
				if (size2 == 1) {
					arrayType = Uint8Array;
				} else {
					arrayType = Uint16Array;
				}
				return new arrayType(result);
			}

            </script>
        
        <script type="text/javascript">

			const kWidth = 640, kHeight = 480;
            
			var glCanvas,
				renderer = null,
				model = null;
			
			var shareButton,
				clearButton;
			
			var sendRotTimer = null;
			var resumeSend = false;
			
			TabControl.onActivate = function() {
				requestAnimFrame(drawScene);
				
				if (resumeSend) {
					sendRotation();
				}
			}
			
			TabControl.onDeactivate = function() {
				cancelAnimFrame(drawScene);
				if (sendRotTimer) {
					clearTimeout(sendRotTimer);
					resumeSend = true;
					sendRotTimer = null;
				}
			}
			
			TabControl.onStreamAdded = function(stream) {
			}
			
			TabControl.onStreamRemoved = function(stream) {
			}
			
			TabControl.onMessageReceived = function(senderId, type, packet) {
				
				if (type == "inviteAccepted") {
					onShareAccepted();
				} else if (type == "inviteDeclined") {
					onShareDeclined();
				} else if (type == "model") {
					loadJSONModel(packet);
				} else if (type == "rotate") {
					if (renderer) {
						renderer.updateModelRotation(packet.matrix);
					}
				} else if (type == "modelReceived") {
					console.log("Received model load confirmation");
					sendRotation();
				}
				
			}
			
			TabControl.onKinectInit = function(proxy) {
			}
			
			TabControl.onNewKinectData = function(videoData, depthData) {
			}
			
            TabControl.onLoad = function() {
                
                glCanvas = MediaExt.createCanvas(kWidth, kHeight);
                glCanvas.style.display = "none";
                glCanvas.style.margin = "20px auto";
                document.getElementById("container").appendChild(glCanvas);
				
				shareButton = document.getElementById("shareButton");
				clearButton = document.getElementById("clearButton");
				
                // **********************
                // Drag and drop with File API
                var dropbox = document.getElementById("dropbox"),
                dropboxContainer = document.getElementById("container"),
				state = document.getElementById("status");
                
                if (typeof window.FileReader === "undefined") {
                    state.className = "fail";
                    state.innerHTML = "File API unavailable, change browser!!!! :)";
                } else {
                    state.className = "success";
                }
                
                dropboxContainer.ondragenter = function () {
                    dropbox.className = "hover";
                    return false;
                };
                dropboxContainer.ondragleave = function () {
                    dropbox.className = "";
                    return false;
                };
                dropboxContainer.ondragover = function () {
                    dropbox.className = "hover";
                    return false;
                };
                dropboxContainer.ondragend = function () {
                    return false;
                };
                dropboxContainer.ondrop = function (e) {
                    
                    dropbox.className = "";
                    
                    e.preventDefault();
                    readFiles(e.dataTransfer.files);
                    
                    return false;
                };
                // **********************
                
                document.getElementById("fileSelect").addEventListener("change", function () { readFiles(this.files); }, false);
            }
            
            function readFiles(files) {
                
                var file = files[0];
                
                var splitName = file.name.split(".");
                if (splitName.length < 2 || splitName[1] !== "ply") {
                    alert("I ONLY ACCEPT .ply FILES! ." + splitName[1] + " FILES ANGER ME! >:(");
                    return;
                }
                // or maybe:
                /*
                 if (file.name.substring(file.name.length - 4) !== ".ply") {
                 }
                 */
                
                var progress = document.getElementById("percentBar");
                var dropbox = document.getElementById("dropbox");
                
                var reader = new FileReader();
                reader.onerror = errorHandler;
                reader.onprogress = updateProgress;
                reader.onabort = function(e) {
                    alert("File read cancelled");
                };
                reader.onloadstart = function(e) {
                    document.getElementById("progressBar").className = "loading";
                };
                reader.onload = function (event) {
                    // Ensure that the progress bar displays 100% at the end.
                    progress.style.width = "100%";
                    progress.textContent = "100%";
                    setTimeout("document.getElementById('progressBar').className='';", 2000);
                    
                    dropbox.style.display = "none";
                    glCanvas.style.display = "block";
                    
					try {
						model = PlyParse.parse(event.target.result);
						console.log(model);
					} catch (error) {
						alert("Error parsing model. " + error);
						return;
					}
					
					var rendererConstructor = model.renderer;
					if (rendererConstructor) {
						
						renderer = new rendererConstructor(glCanvas);
						
						positionModel(model);
						
						console.log(JSON.stringify({matrix:renderer.getRotationMatrix()}));
						
						var he = renderer.getRotationMatrix();
						he[0] = he[5] = he[10] = he[15] = 0.5;
						renderer.updateModelRotation(he);
						
						if (rendererConstructor == PhongRenderer) {
							renderer.bufferData(model.pos, model.normals, model.faces);
						} else if (rendererConstructor == MeshRenderer) {
							renderer.bufferData(model.pos, model.colors, model.faces);
						} else if (rendererConstructor == PointCloudRenderer) {
							renderer.bufferData(model.pos, model.colors);
						}
						
						clearButton.disabled = false;
						shareButton.disabled = false;
					}
					// drawScene();
                };
                
                console.log(file);
                
                // reader.readAsDataURL(file);
                // reader.readAsText(file);
				reader.readAsArrayBuffer(file);
            }
			
			function positionModel(model) {
				
				if (model.pos) {
					
					// Calculate position for the object
					var vertices = model.pos;
					
					var maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity,
						minX=Infinity, minY=Infinity, minZ=Infinity;
					for (var i = 0; i < vertices.length;) {
						var x = vertices[i++],
							y = vertices[i++],
							z = vertices[i++];
						maxX = Math.max(maxX, x);
						maxY = Math.max(maxY, -y);
						maxZ = Math.max(maxZ, -z);
						
						minX = Math.min(minX, x);
						minY = Math.min(minY, -y);
						minZ = Math.min(minZ, -z);
					}
					var cx = (maxX + minX) / 2;
					var cy = (maxY + minY) / 2;
					var cz = (maxZ + minZ) / 2;
					
					renderer.setCenterOfRotation([cx, cy, cz]);
					renderer.setPosition([0, 0, -(maxX - minX) / Math.atan(22.5 * Math.PI / 180)]);
				}
			}
			
			function serializeModel(model) {
				
				var pos = model.pos ? new Array(model.pos.length) : [];
				var normals = model.normals ? new Array(model.normals.length) : [];
				var faces = model.faces ? new Array(model.faces.length) : [];
				var colors = model.colors ? new Array(model.colors.length) : [];
				
				for (var i = 0, len = pos.length; i < len; i++) {
					pos[i] = model.pos[i];
				}
				for (var i = 0, len = normals.length; i < len; i++) {
					normals[i] = model.normals[i];
				}
				for (var i = 0, len = faces.length; i < len; i++) {
					faces[i] = model.faces[i];
				}
				for (var i = 0, len = colors.length; i < len; i++) {
					colors[i] = model.colors[i];
				}
				return {pos:pos,
						normals:normals,
						faces:faces,
						colors:colors,};
			}
			
			function loadJSONModel(model) {

				clearGLCanvas();
				
				// Select renderer
				if (model.pos) {
					if (!model.faces) {
						// No faces means it's a point cloud
						if (model.colors) {
							renderer = new PointCloudRenderer(glCanvas);
							renderer.bufferData(new Float32Array(model.pos),
												new Float32Array(model.colors));
						}
					} else {
						if (model.normals) {
							renderer = new PhongRenderer(glCanvas);
							renderer.bufferData(new Float32Array(model.pos),
												new Float32Array(model.normals),
												new Uint16Array(model.faces));
						} else if (model.colors) {
							renderer = new MeshRenderer(glCanvas);
							renderer.bufferData(new Float32Array(model.pos),
												new Float32Array(model.colors));
						}
					}
				}
				
				positionModel(model);
				
				if (renderer) {
					dropbox.style.display = "none";
					glCanvas.style.display = "block";
					TabControl.sendMessage("share", "modelReceived", {});
				}
			}
			
			function downloadFile(url, success) {
				var req = new XMLHttpRequest();
				req.open('GET', url, true);
				req.responseType = "arraybuffer";
				req.onreadystatechange = function () {
					if (xhr.readyState == 4) {
						if (success) success(xhr.response);
					}
				};
				req.send(null);
			}
            
            function updateProgress(evt) {
                
                var progress = document.getElementById("percentBar");
                
                // evt is an ProgressEvent.
                if (evt.lengthComputable) {
                    var percentLoaded = Math.round((evt.loaded / evt.total) * 100);
                    // Increase the progress bar length.
                    if (percentLoaded < 100) {
                        progress.style.width = percentLoaded + "%";
                        progress.textContent = percentLoaded + "%";
                    }
                }
            }
            
            function errorHandler(evt) {
                switch(evt.target.error.code) {
                    case evt.target.error.NOT_FOUND_ERR:
                    alert("File Not Found!");
                    break;
                    case evt.target.error.NOT_READABLE_ERR:
                    alert("File is not readable");
                    break;
                    case evt.target.error.ABORT_ERR:
                    break; // noop
                    default:
                    alert("An error occurred reading this file.");
                };
            }
			
			
			function drawScene() {
				requestAnimFrame(drawScene);
				if (renderer) {
					renderer.render();
				}
			}
            
			function sendShareInvite() {
				TabControl.sendMessage("index", "share", {});
				shareButton.disabled = true;
			}
			
			function onShareAccepted() {
				if (model) {
					
					console.log("Sending model");
					console.log(model);
					
					TabControl.sendMessage("share", "model", serializeModel(model));

					console.log("Waiting for confirmation...");
				}
			}
			
			function onShareDeclined() {
				
				// TODO: display message
				
				clearTimeout(sendRotTimer);
				sendRotTimer = null;
				shareButton.disabled = false;
			}
			
			function sendRotation() {
				if (renderer) {
					TabControl.sendMessage("share", "rotate", {matrix:renderer.getRotationMatrix()});
					setTimeout(sendRotation, 100);
				}
			}
			
			function clearGLCanvas() {
				
				// Remove the renderer
				renderer = null;
				
				// Setting width and height clears the canvas
				glCanvas.width = glCanvas.width;
				glCanvas.height = glCanvas.height;
				
				dropbox.style.display = "block";
				glCanvas.style.display = "none";
				
				clearButton.disabled = true;
			}
			
            </script>
        
    </head>
	
	<body>
        
        <h1>Point Cloud Drag and Drop</h1>
        <div id="container">
            <div id="dropbox">
                <p id="status">Drop a .ply file here, , or use this fine button:<br><br><input type="file" id="fileSelect"></p>
                <div id="progressBar">
                    <div id="percentBar">0%</div>
                </div>
            </div>
        </div>
		
		<button id="shareButton" onclick="sendShareInvite();" style="padding:1em; margin:0em;" disabled=true>Share!</button>
		<button id="clearButton" onclick="clearGLCanvas();" style="padding:1em; margin:0em;" disabled=true>Clear</button>
	
	</body>
    
</html>