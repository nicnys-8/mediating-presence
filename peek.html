
<html>
    <head>
        
        <title>Peek!</title>
        
		<script type="text/javascript" src="js/tab-control.js"></script>
        <script type="text/javascript" src="js/mediaext.js"></script>
        <script type="text/javascript" src="js/lib/webgl-utils.js"></script>
        <script type="text/javascript" src="js/lib/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="js/image-handling.js"></script>
		<script type="text/javascript" src="js/kinect-plugin-proxy-zigfu.js"></script>
		<script type="text/javascript" src="js/point-cloud-renderer-x.js"></script>
		
        <link rel="stylesheet" type="text/css" href="css/pb.css"/>
        <link rel="stylesheet" type="text/css" href="css/pointcloud.css"/>
        
        <script type="text/javascript">
            
            const VIDEO_DISPLAY_WIDTH = 640, VIDEO_DISPLAY_HEIGHT = 480;
			const KINECT_RGB_WIDTH = 160, KINECT_RGB_HEIGHT = 120;
            const KINECT_DEPTH_WIDTH = 160, KINECT_DEPTH_HEIGHT = 120;
			
			var isActive = false;
			
			var pluginProxy;
			var senderIds = [];
			var displayedStreams = {};
			
			var PeekDisplay = function() {
				this.canvas = MediaExt.createCanvas(VIDEO_DISPLAY_WIDTH, VIDEO_DISPLAY_HEIGHT);
				this.renderer = new PointCloudRendererX(this.canvas);
				
				var ctx = document.createElement("canvas").getContext("2d");
				this.videoData = ctx.createImageData(KINECT_RGB_WIDTH, KINECT_RGB_HEIGHT);
				this.depthBuffer = new Array(KINECT_DEPTH_WIDTH * KINECT_DEPTH_HEIGHT);
				
				for (var i = 0, len = this.depthBuffer.length; i < len; ++i) {
					this.depthBuffer[i] = 0;
				}
			}
			
			TabControl.onActivate = function() {
				isActive = true;
				requestAnimFrame(drawScene);
			}
			
			TabControl.onDeactivate = function() {
				isActive = false;
				cancelAnimFrame(drawScene);
			}
			
			TabControl.onLocalStreamInit = function(stream) {
			}
			
			TabControl.onStreamAdded = function(stream) {
				// Create a PeekDisplay to render the Kinect data
				var streamId = stream.getID();
				var pd = new PeekDisplay();
				displayedStreams[streamId] = pd;
				senderIds.push(streamId);
				// Add its canvas element
				document.getElementById("container").appendChild(pd.canvas);
				
				var myPD = displayedStreams["me"];
				myPD.canvas.style.display = "none";
			}
			
			TabControl.onStreamRemoved = function(stream) {

				var streamId = stream.getID();
				pd = displayedStreams[streamId];
				
				if (pd) {
					
					// Remove the canvas element
					pd.canvas.parentNode.removeChild(pd.canvas);
					// Unnecessary(?) cleanup
					pd.renderer = null;
					pd.canvas = null;
					
					// Remove the stream and PeekDisplay from lists
					delete displayedStreams[streamId];
					var index = senderIds.indexOf(streamId);
					if (index != -1) {
						senderIds.splice(index, 1);
					}
				}
			}
			
			TabControl.onMessageReceived = function(senderId, type, data) {
				
				if (type == "kinect") {
					
					if (isActive && pluginProxy) {
						
						var pd = displayedStreams[senderId];
						
						pluginProxy.decodeVideo(data.video, pd.videoData.data);
						pluginProxy.decodeDepth(data.depth, pd.depthBuffer);
						
						updateScene(senderId, pd.videoData, pd.depthBuffer);
					}
				}
			}
			
			TabControl.onKinectInit = function(proxy) {
				proxy.addHeadPositionListener(function(headPos) {
											  for (var i = 0; i < senderIds.length; i++) {
												var pd = displayedStreams[senderIds[i]];
												// console.log(headPos);
												pd.renderer.headMoved(headPos);
											  }});
				pluginProxy = proxy;
			}
			
			const SEND_RATE = 3;
			var sendTick = 0;
			
			TabControl.onNewKinectData = function(videoData, depthData, rawVideo, rawDepth) {
				
				// TODO: Send data even when tab is inactive?
				if (!isActive) {
					return;
				}
				
				// DEBUG: show the video in a separate canvas
				// canvas.getContext("2d").putImageData(videoData, 0, 0);
				
				// Update local Kinect stream, if no other streams are available
				if (senderIds.length == 1) {
					updateScene("me", videoData, depthData);
				}
				
				var doSend = document.getElementById("streamData").checked;
				if (doSend && sendTick % SEND_RATE == 0) {
					// Send the Kinect data
					TabControl.sendMessage("peek", "kinect", {video:rawVideo, depth:rawDepth});
				}
				sendTick++;
            }
			
            TabControl.onLoad = function() {
				var pd = new PeekDisplay();
				senderIds.push("me");
				displayedStreams["me"] = pd;
				document.getElementById("container").appendChild(pd.canvas);
            }
			
			function updateScene(senderId, video, depth) {
				
				var pd = displayedStreams[senderId];
				
				if (!pd) {
					return;
				}
				
				var renderer = pd.renderer;
				
				var maxDepth = 4000;
				var pos = [];
				
				var zScale = 1.0 / parseFloat(document.getElementById("zScale").value);
				var brightness = parseFloat(document.getElementById("brightness").value);
				var lerp = document.getElementById("lerp").checked;
				
				renderer.setTexture(video);
				
                for (var y = 0, index = 0; y < KINECT_DEPTH_HEIGHT; y++) {
                    for (var x = 0; x < KINECT_DEPTH_WIDTH; x++, index++) {
                        
                        var z = depth[index];
						
                        var zr = depth[index + 1];
						var zb = depth[index + KINECT_DEPTH_WIDTH];
						var zbr = depth[index + KINECT_DEPTH_WIDTH + 1];
						
                        if (z > 0 && z < maxDepth) {
							
							pos.push(x, y, z);
							
							if (lerp) {
								
								if (zr
									&& x < KINECT_DEPTH_WIDTH - 1
									&& Math.abs(zr - z) < 50) {
									pos.push(x + 0.5,
											 y,
											 (z + zr) * 0.5);
								}
								
								if (zb
									&& y < KINECT_DEPTH_HEIGHT - 1
									&& Math.abs(zb - z) < 50) {
									pos.push(x,
											 y + 0.5,
											 (z + zb) * 0.5);
								}
								
								if (zbr
									&& x < KINECT_DEPTH_WIDTH - 1
									&& y < KINECT_DEPTH_HEIGHT - 1
									&& Math.abs(zbr - z) < 50) {
									pos.push(x + 0.5,
											 y + 0.5,
											 (z + zbr) * 0.5);
								}
							}
                        }
                    }
                }
				
				renderer.setBrightness(brightness);
				renderer.setScale([1.0, -1.0, -zScale]);
                renderer.setCenterOfRotation([-80, -60, -1000]);
				renderer.setPosition([0, 0, -200]);
				renderer.bufferData(pos);
				
                // renderer.render();
			}
			
			function drawScene() {
				requestAnimFrame(drawScene);
				var first = (senderIds.length > 1) ? 1 : 0;
				for (var i = first; i < senderIds.length; i++) {
					var pd = displayedStreams[senderIds[i]];
					pd.renderer.render();
				}
			}
			
			function resetCameras() {
				for (var i = 0; i < senderIds.length; i++) {
					var pd = displayedStreams[senderIds[i]];
					pd.renderer.resetCamera();
				}
			}
			
            </script>
        
    </head>
	
	<body>
        
        <h1>Peek!</h1>
        <div id="container">
        </div>
		
		<button onclick="resetCameras();">Reset camera</button>
		<table style="margin:0px auto;">
			<tr>
				<td style="text-align:right;">Z-Scale:</td>
				<td><input id="zScale" type="range" min="1" max="20" value="5" step="0.05"></td>
			</tr><tr>
				<td style="text-align:right;">Brightness:</td>
				<td><input id="brightness" type="range" min="0" max="5" step="0.01" value="1"></td>
			</tr><tr>
				<td style="text-align:right;">Interpolate:</td>
				<td><input id="lerp" type="checkbox"></td>
			</tr>
			</tr><tr>
				<td style="text-align:right;">Stream:</td>
				<td><input id="streamData" type="checkbox" checked="true"></td>
			</tr>
		</table>
			
</html>

