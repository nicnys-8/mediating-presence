
<html>
    <head>
        
        <title>Peek!</title>
        
		<script type="text/javascript" src="js/tab-control.js"></script>
        <script type="text/javascript" src="js/mediaext.js"></script>
        <script type="text/javascript" src="js/lib/webgl-utils.js"></script>
        <script type="text/javascript" src="js/lib/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="js/image-handling.js"></script>
		<script type="text/javascript" src="js/kinect-proxy-zigfu.js"></script>
		<script type="text/javascript" src="js/point-cloud-renderer-x.js"></script>
		
        <link rel="stylesheet" type="text/css" href="css/pb.css"/>
        <link rel="stylesheet" type="text/css" href="css/pointcloud.css"/>
        
        <script type="text/javascript">
            
            const VIDEO_DISPLAY_WIDTH = 640, VIDEO_DISPLAY_HEIGHT = 480;
			
			var isActive = false,
				streamIDs = [],
				displayedStreams = {},
				frameCount = 0;
			
			var StreamCodec = function() {
				
				var API = {},
					videoCanvas = MediaExt.createCanvas(160, 120),
					videoContext = videoCanvas.getContext("2d"),
					videoImage = new Image(),
					imageData = videoContext.createImageData(160, 120),
					depthCanvas = MediaExt.createCanvas(160, 120),
					depthContext = depthCanvas.getContext("2d"),
					depthImage = new Image();
				
				depthImage.onload = null;
				videoImage.onload = null;
				
				API.encodeVideo = function(videoData) {
					videoContext.putImageData(videoData, 0, 0);
					return videoCanvas.toDataURL("image/webp", 0.5);
				};
				
				API.decodeVideo = function(webpVideoString, callback) {
					
					/*if (videoImage.onload) {
						console.log("videogrrr"); return;
					}
					videoImage.src = "";*/
					
					/*videoImage.onload = function() {
						// Do something?
						videoContext.drawImage(videoImage, 0, 0, 160, 120);
						callback(videoCanvas);
						videoImage.onload = null;
					};*/
					
					videoImage.src = webpVideoString;
					videoContext.drawImage(videoImage, 0, 0, 160, 120);
					callback(videoCanvas);
				};
				
				API.encodeDepth = function(depthData) {
					
					var i = 0, j = 0,
						len = depthData.length,
						data = imageData.data,
						z;
					
					while (i < len) {
						z = depthData[i];
						data[j + 0] = (z & 0xff00) >> 8;
						data[j + 1] = (z & 0x00ff);
						data[j + 2] = 255;
						data[j + 3] = 255;
						i += 1;
						j += 4;
					}
					depthContext.putImageData(imageData, 0, 0);
					return depthCanvas.toDataURL("image/webp", 0.5);
				};
				
				API.decodeDepth = function(webpDepthString, dst, callback) {
					
					/*if (depthImage.onload) {
						console.log("depthgrrr"); return;
					}
					depthImage.src = "";*/
					depthImage.src = webpDepthString;
					
					// depthImage.onload = function() {
						depthContext.drawImage(depthImage, 0, 0, 160, 120);
						var data = depthContext.getImageData(0, 0, 160, 120).data,
							i = 0, j = 0, len = data.length;
						
						var x = 0;
					
						while (j < len) {
							dst[i] = (data[j] << 8) | data[j + 1];
							x += data[j + 2];
							
							i += 1;
							j += 4;
						}
					
						if (x === dst.length * 255) {
							callback(dst);
						} else {
							callback(null);
						}
						
						depthImage.onload = null;
					// };
				};
				
				return API;
			}();
			
			var PeekDisplay = function() {
				
				var zWidth = KinectProxy.DEPTH_DATA_WIDTH,
					zHeight = KinectProxy.DEPTH_DATA_HEIGHT,
					ctx = document.createElement("canvas").getContext("2d"),
					vertices, vertices2x, index;
				
				this.canvas = MediaExt.createCanvas(VIDEO_DISPLAY_WIDTH, VIDEO_DISPLAY_HEIGHT);
				this.renderer = new PointCloudRendererX(this.canvas);
				this.videoData = ctx.createImageData(KinectProxy.RGB_DATA_WIDTH,
													 KinectProxy.RGB_DATA_HEIGHT);
				this.depthBuffer = new Array(zWidth * zHeight);
				for (var i = 0, len = this.depthBuffer.length; i < len; ++i) {
					this.depthBuffer[i] = 0;
				}
				
				vertices = new Float32Array(zWidth * zHeight * 3),
				index = 0;
				for (var y = 0; y < zHeight; y++) {
					for (var x = 0; x < zWidth; x++) {
						vertices[index++] = x;
						vertices[index++] = y;
						vertices[index++] = 0;
					}
				}
				
				vertices2x = new Float32Array(zWidth * zHeight * 3 * 4);
				index = 0;
				for (var y = 0; y < zHeight; y += 0.5) {
					for (var x = 0; x < zWidth; x += 0.5) {
						vertices2x[index++] = x;
						vertices2x[index++] = y;
						vertices2x[index++] = 0;
					}
				}
				
				this.vertices = vertices;
				this.vertices2x = vertices2x;
			};
			
			TabControl.onLoad = function() {
				var pd = new PeekDisplay();
				streamIDs.push("me");
				displayedStreams["me"] = pd;
				document.getElementById("container").appendChild(pd.canvas);
            };
			
			TabControl.onActivate = function() {
				isActive = true;
				requestAnimFrame(drawScene);
			};
			
			TabControl.onDeactivate = function() {
				isActive = false;
				cancelAnimFrame(drawScene);
			};
			
			TabControl.onLocalStreamInit = function(stream) {
			};
			
			TabControl.onStreamAdded = function(stream) {
				
				// Create a PeekDisplay to render the Kinect data
				var streamId = stream.getID();
				var pd = new PeekDisplay();
				displayedStreams[streamId] = pd;
				streamIDs.push(streamId);
				
				// Add its canvas element
				document.getElementById("container").appendChild(pd.canvas);
				
				var myPD = displayedStreams["me"];
				myPD.canvas.style.display = "none";
			};
			
			TabControl.onStreamRemoved = function(stream) {

				var streamId = stream.getID();
				pd = displayedStreams[streamId];
				
				if (pd) {
					
					// Remove the canvas element
					pd.canvas.parentNode.removeChild(pd.canvas);
					// Unnecessary(?) cleanup
					pd.renderer = null;
					pd.canvas = null;
					
					// Remove the stream and PeekDisplay from lists
					delete displayedStreams[streamId];
					var index = streamIDs.indexOf(streamId);
					if (index != -1) {
						streamIDs.splice(index, 1);
					}
				}
			};
			
			TabControl.onMessageReceived = function(senderId, type, data) {
				
				if (type == "kinect") {
					
					if (isActive) {
						
						var pd = displayedStreams[senderId];
						
						if (data.video) {
							KinectProxy.decodeVideo(data.video, pd.videoData.data);
							KinectProxy.decodeDepth(data.depth, pd.depthBuffer);
							updateScene(senderId, pd.videoData, pd.depthBuffer);
						} else {
							KinectProxy.decodeDepth(data.depth, pd.depthBuffer);
							updateScene(senderId, null, pd.depthBuffer);
						}
					}
				}
			};
			
			TabControl.onKinectInit = function(proxy) {
				proxy.addHeadPositionListener(function(headPos) {
											  for (var i = 0; i < streamIDs.length; i++) {
												var pd = displayedStreams[streamIDs[i]];
												// console.log(headPos);
												pd.renderer.headMoved(headPos);
											  }});
			};
			
			var hej = [];
			TabControl.onNewKinectData = function(videoData, depthData, rawVideo, rawDepth) {
				
				// TODO: Send data even when tab is inactive?
				if (!isActive) {
					return;
				}
				
				var sendData = document.getElementById("streamData").checked,
					sendVideo = document.getElementById("useVideo").checked,
					sendRate = parseInt(document.getElementById("frameSkip").value);
				
				// DEBUG: show the video in a separate canvas
				// canvas.getContext("2d").putImageData(videoData, 0, 0);
				
				// Update local Kinect stream, if no other streams are available
				if (streamIDs.length == 1 && frameCount % sendRate == 0) {
					
					var vid = StreamCodec.encodeVideo(videoData);
					var dep = StreamCodec.encodeDepth(depthData);
					
					console.log((vid.length + dep.length));
					console.log((vid.length + dep.length) / (rawVideo.length + rawDepth.length));
					
					StreamCodec.decodeDepth(dep, hej, function(result) {
												updateScene("me", null, result);
											  });
					
					StreamCodec.decodeVideo(vid, function(result) {
												updateScene("me", result, null);
											  });
					
					// updateScene("me", null/*StreamCodec.decodeVideo(vid)*/, hej);
				}
				/*
				if (sendData && frameCount % sendRate == 0) {
					var data = {
						depth:StreamCodec.encodeDepth(depthData) // rawDepth,
					};
					if (sendVideo) {
						data.video = StreamCodec.encodeVideo(videoData); // rawVideo;
					}
					// Send the Kinect data
					TabControl.sendMessage("peek", "kinect", data);
				}
				 */
				frameCount++;
            };
			
			function updateScene(senderId, video, depth) {
				
				var pd = displayedStreams[senderId];
				
				if (!pd) {
					return;
				}
				
				var renderer = pd.renderer,
					maxDepth = 5000,
					zScale = 1.0 / parseFloat(document.getElementById("zScale").value),
					brightness = parseFloat(document.getElementById("brightness").value),
					lerp = document.getElementById("lerp").checked,
					useVideo = document.getElementById("useVideo").checked,
					pos = lerp ? pd.vertices2x : pd.vertices,
					width = KinectProxy.DEPTH_DATA_WIDTH,
					height = KinectProxy.DEPTH_DATA_HEIGHT,
					x, y, z,
					zr, zb, zbr,
					zLerp, index,
					index2x = 2, width2x = width * 6;
				
				if (video && useVideo) {
					renderer.setTexture(video);
				}
				
				if (!depth) {
					return;
				}
				
				if (lerp) {
					
					for (y = 0, index = 0; y < height; y++) {
						for (x = 0; x < width; x++, index++, index2x += 6) {
							
							z = depth[index];
							zr = depth[index + 1];
							zb = depth[index + width];
							zbr = depth[index + width + 1];
							
							pos[index2x] = z;
							
							// Interpolate right
							zLerp = (zr && x < width - 1 && Math.abs(zr - z) < 30)
										? (z + zr) * 0.5 : 0;
							pos[index2x + 3] = zLerp;
								
							// Interpolate bottom
							zLerp = (zb && y < height - 1 && Math.abs(zb - z) < 30)
										? (z + zb) * 0.5 : 0;
							pos[index2x + width2x] = zLerp;
								
							// Interpolate bottom-right
							zLerp = (zbr && x < width - 1 && y < height - 1 && Math.abs(zbr - z) < 30)
										? (z + zbr) * 0.5 : 0;
							pos[index2x + width2x + 3] = zLerp;
						}
						index2x += width2x;
					}
					
				} else {
					for (y = 0, index = 0; y < height; y++) {
						for (x = 0; x < width; x++, index++) {
							pos[index * 3 + 2] = depth[index];
							/* var z = depth[index];
							if (z > 0 && z < maxDepth) {
								pos[index * 3 + 2] = z;
							}*/
						}
					}
				}
				/*
				for (var y = 0, index = 0; y < height; y++) {
                    for (var x = 0; x < width; x++, index++) {
                        
                        var z = depth[index];
						
                        var zr = depth[index + 1];
						var zb = depth[index + width];
						var zbr = depth[index + width + 1];
						
                        if (z > 0 && z < maxDepth) {
							
							pos.push(x, y, z);
							
							if (lerp) {
								
								if (zr
									&& x < width - 1
									&& Math.abs(zr - z) < 50) {
									pos.push(x + 0.5,
											 y,
											 (z + zr) * 0.5);
								}
								
								if (zb
									&& y < height - 1
									&& Math.abs(zb - z) < 50) {
									pos.push(x,
											 y + 0.5,
											 (z + zb) * 0.5);
								}
								
								if (zbr
									&& x < width - 1
									&& y < height - 1
									&& Math.abs(zbr - z) < 50) {
									pos.push(x + 0.5,
											 y + 0.5,
											 (z + zbr) * 0.5);
								}
							}
                        }
                    }
                }
				*/
				
				renderer.setUseVideo(useVideo);
				renderer.setBrightness(brightness);
				renderer.setScale([1.0, -1.0, -zScale]);
                renderer.setCenterOfRotation([-80, -60, -1000]);
				renderer.setPosition([0, 0, -200]);
				renderer.bufferData(pos);
			}
			
			function drawScene() {
				requestAnimFrame(drawScene);
				var first = (streamIDs.length > 1) ? 1 : 0;
				for (var i = first; i < streamIDs.length; i++) {
					var pd = displayedStreams[streamIDs[i]];
					pd.renderer.render();
				}
			}
			
			function resetCameras() {
				for (var i = 0; i < streamIDs.length; i++) {
					var pd = displayedStreams[streamIDs[i]];
					pd.renderer.resetCamera();
				}
			}
			
            </script>
        
    </head>
	
	<body>
        
        <h1>Peek!</h1>
		
		<div id="controls"
			style="padding:0px 20px 20px 20px; 
					border:1px solid black; 
					border-radius:5px; 
					position:absolute; 
					left:20px; 
					top:60px;">
			
			<h2>Controls</h2>
			<table style="margin:0px auto;">
				<tr>
					<td style="text-align:right;">Z-Scale:</td>
					<td><input id="zScale" type="range" min="1" max="20" value="5" step="0.05"></td>
				</tr><tr>
					<td style="text-align:right;">Brightness:</td>
					<td><input id="brightness" type="range" min="0" max="5" step="0.01" value="1"></td>
				</tr><tr>
					<td style="text-align:right;">Interpolate:</td>
					<td><input id="lerp" type="checkbox"></td>
				</tr><tr>
					<td style="text-align:right;">Video texture:</td>
					<td><input id="useVideo" type="checkbox"></td>
				</tr><tr>
					<td style="text-align:right;">Stream:</td>
					<td><input id="streamData" type="checkbox" checked="true"></td>
				</tr><tr>
					<td style="text-align:right;">Skip frames:</td>
					<td><input id="frameSkip" type="range" min="1" max="30" step="1" value="3"></td>
				</tr>
			</table>
			
			<button onclick="resetCameras();">Reset camera</button>
			
		</div>
		
        <div id="container">
        </div>

</html>

