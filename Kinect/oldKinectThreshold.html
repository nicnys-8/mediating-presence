<!--
 thresholds the Kinect RGB video based on data from the depth video
 -->

<!DOCTYPE html>
<html>
    <head>
        <title>Kinect camera access test</title>
        
        <script src="../lib/zig.js"></script>
        <script src="../lib/kinectVideoDecoder.js"></script>
        
        <script>
            
            // Just some variables, might be moved later...
            var plugin;
            
            var depthCanvas;
            var depthContext;
            var depthData;
            var rgbCanvas;
            var rgbContext
            var rgbData;
            
            var refImage;
            var refImageCountdown;
            var temp;
            var mask;
            
            
            /*
             Requests video streams and starts periodically updating the canvases
             */
            function init() {
                plugin = document.getElementById("ZigPlugin");
                //zig.embed();
                
                depthCanvas = document.getElementById("depthCanvas");
                depthContext = depthCanvas.getContext("2d");
                rgbCanvas = document.getElementById("rgbCanvas");
                rgbContext = rgbCanvas.getContext("2d");
                
                temp = rgbContext.createImageData(rgbCanvas.width, rgbCanvas.height);
                
                clearMask();
                
                plugin.requestStreams({updateDepth:true, updateImage:true});
                plugin.addEventListener("NewFrame", function() { // triggered every new kinect frame
                                        drawDepthImage();
                                        drawRGBImage();
                                        takeNewRefImage();
                                        });
            }
            
            /*
             Take a snapshot from the Kinect RGB video and draw
             it in a canvas
             */
            function drawPlainRGBImage() {
                
                rgbImage = kinectVideoDecoder.decodeRGB(plugin.imageMap);
                for (var i = 0; i < rgbImage.length; i++) {
                    temp.data[i] = rgbImage[i];
                }
                rgbContext.putImageData(temp, 0, 0);
            }
            
            /*
             Take a snapshot from the Kinect RGB video and draw
             a thresholded version in a canvas
             */
            function drawRGBImage(image) {
                var rgbData = kinectVideoDecoder.decodeRGB(plugin.imageMap);
                var index = 0;
                for (var i = 0; i < mask.length; i++) {
                    index = i * 4;
                    if (mask[i] == 1) {
                        temp.data[index] = rgbData[index];
                        temp.data[index + 1] = rgbData[index + 1];
                        temp.data[index + 2] = rgbData[index + 2];
                        temp.data[index + 3] = 255; // Full opacity
                    } else {
                        temp.data[index] = 255;
                        temp.data[index + 1] = 255;
                        temp.data[index + 2] = 255;
                        temp.data[index + 3] = 255; // Full opacity
                    }
                }
                rgbContext.putImageData(temp, 0, 0);
            }
            
            
            /*
             Take a snapshot from the Kinect depth video and draw
             it in a canvas
             */
            function drawDepthImage() {
                var depthData = kinectVideoDecoder.decodeDepth(plugin.depthMap);
                var index = 0;
                var depthValue;
                for (var i = 0; i < depthData.length; i+=2) {
                    depthValue = depthData[i] | (depthData[i + 1] << 8);
                    depthValue = depthValue / 2047;
                    depthValue = depthValue * 255;
                    
                    temp.data[index++] = depthValue;
                    temp.data[index++] = 0;
                    temp.data[index++] = 0;
                    temp.data[index++] = 255;
                }
                
                // If a reference image has been taken,
                // subtract it from the new depth image
                if (refImage) {
                    produceMask();
                }
                depthContext.putImageData(temp, 0, 0);
            }
            
            /*
             Creates an array containing a 1 for each pixel in rgbCanvas
             */
            function clearMask() {
                var pixelsInCanvas = (rgbCanvas.width * rgbCanvas.height);
                mask = new Array(pixelsInCanvas);
                for (var i = 0; i < mask.length; i++) {
                    mask[i] = 1;
                }
            }
            
            /*
             Produces a binary mask where each bit is set to 1
             if the corresponding pixels in refImage and temp differ,
             otherwise 0
             */
            function produceMask() {
                var thresholdValue = 96;
                var difference;
                var index = 0;
                // Do this another way....EWEFFWFFDFE
                for (var i = 0; i < mask.length; i++) {
                    index = i * 4;
                    if (temp.data[index] == 0) {
                        difference = 0;
                    } else {
                        difference = Math.abs(temp.data[index] - refImage.data[index]);
                    }
                    if ( difference > thresholdValue) {
                        mask[i] = 1;
                    } else {
                        mask[i] = 0;
                    }
                }
            }
            
            
            /*
             Take a snapshot of the depth video stream to be used
             for thresholding
             */
            function takeNewRefImage() {
                // If it's the first step of the reference image process,
                // copy the current depht image data
                if (refImageCountdown == 10) {
                    refImage = depthContext.getImageData(0, 0, depthCanvas.width, depthCanvas.height);
                }
                // Then fill in the reference image ten times in a row
                // to avoid unecessary black spots
                if (refImageCountdown > 0) {
                    
                    var length = refImage.height * refImage.width;
                    for (var i = 0; i < length; i++) {
                        if (refImage[i] == 0) refImage[i] = temp.data[i];
                    }
                    // Finally, decrease the counter
                    refImageCountdown--;
                }
            }
            
            function startTakingRefImages() {
                refImageCountdown = 10;
            }
            
            
            </script>
    </head>
    <body onload="init();">
        
        <div id="pluginContainer">
            <object id="ZigPlugin" type="application/x-zig" width="0" height="0">
                <param name="onload" value="zigPluginLoaded">
                    </object>
        </div>
        
        <div style="position: relative;">
            <canvas id="rgbCanvas" width="160" height="120"
                style="position: relative; left: 0; top: 0; z-index: 0;">
            </canvas>
            
            <canvas id="depthCanvas" width="160" height="120"
                style="position: relative; left: 200; top: 130; z-index: 0;">
            </canvas>
            
        </div>
        
        <div>
            <input type="button" id="refButton" onclick="startTakingRefImages()" value="Take reference image" > </input>
        </div>
        
    </body>
</html>