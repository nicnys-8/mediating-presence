<!doctype html>
<html lang="en">
    <head>
        <title>Cube Game</title>
        <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                
                </head>
    <body style="overflow:hidden; margin:0px">
        
        <div id="message"></div>
        
        <script src="../js/lib/Three.js"></script>
        <script src="../js/mouse-interface.js"></script>
        <script src="../js/klotski-block.js"></script>
        
        <script>
            
            // Camera constants
            const VIEW_ANGLE = 45;
            const gridSize = 50;
            
            const SCREEN_WIDTH = window.innerWidth;
            const SCREEN_HEIGHT = window.innerHeight;
            
            const ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
            const NEAR = 0.1;
            const FAR = 20000;
            
            var container, scene, camera, renderer, controls;
            
            var mouseXOnMouseDown = 0;
            var selected = null;
            
            var floor;
            
            var blocks = [];
            var obstacles = [];
            
            var mouseCubeOffset = new THREE.Vector3(0, 0, 0);
            
            init();
            tick();
            
            
            /**
             Set up the scene
             */
            function init() {
                
                Klotski.setGridSize(gridSize);
                
                // Scene
                scene = new THREE.Scene();
                
                // Camera
                camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
                scene.add(camera);
                camera.position.set(
                                    gridSize * 2,
                                    gridSize * 10,
                                    gridSize * 6
                                    );
                
                camera.lookAt(new THREE.Vector3(
                                                gridSize * 2,
                                                0,
                                                gridSize * 2.5));
                
                // Renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
                container = document.createElement('div');
                document.body.appendChild(container);
                container.appendChild(renderer.domElement);
                
                // Events -- Oy!!!! Make this work again later!
                //THREEx.WindowResize(renderer, camera);
                
                // Point light
                var light = new THREE.PointLight(0xffffff);
                light.position.set(0, 250, 100);
                scene.add(light);
                
                // Ambient light
                var light = new THREE.AmbientLight(0x303030); // soft white light
                scene.add(light);
                
                // Floor
                var floorMaterial = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture('../images/grass.png') });
                
                floorMaterial.map.wrapS = floorMaterial.map.wrapT = THREE.RepeatWrapping;
                floorMaterial.map.repeat.set(3, 3);
                
                var floorGeometry = new THREE.PlaneGeometry(600, 800, 10, 10);
                floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.doubleSided = true;
                
                floor.rotation.x -= Math.PI / 2; // Rotate the floor correctly
                floor.position.set(gridSize * 2, -0.5, 0); // Move down a tiny bit to prevent flickering
                
                scene.add(floor);
                
                /*-------------
                 === Blocks ===
                 -------------*/
                var block = new KlotskiBlock(2, 1);
                block.snapToGridPoint(0, 0);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(2, 1);
                block.snapToGridPoint(2, 0);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(2, 1);
                block.snapToGridPoint(0, 1);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(2, 1);
                block.snapToGridPoint(0, 2);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(2, 1);
                block.snapToGridPoint(2, 2);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                                
                block = new KlotskiBlock(1, 1);
                block.snapToGridPoint(0, 3);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(1, 1);
                block.snapToGridPoint(1, 3);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(1, 1);
                block.snapToGridPoint(0, 4);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(1, 1);
                block.snapToGridPoint(1, 4);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                
                block = new KlotskiBlock(2, 2);
                block.snapToGridPoint(2, 3);
                scene.add(block);
                blocks.push(block);
                obstacles = obstacles.concat(block);
                block.setSuperDuper();
                
                
                /*-----------
                === Walls ===
                -----------*/
                var wall = new KlotskiWall(1, 7);
                wall.snapToGridPoint(-1, -1);
                scene.add(wall);
                obstacles = obstacles.concat(wall);
                
                wall = new KlotskiWall(1, 7);
                wall.snapToGridPoint(4, -1);
                scene.add(wall);
                obstacles = obstacles.concat(wall);
                
                wall = new KlotskiWall(4, 1);
                wall.snapToGridPoint(0, -1);
                scene.add(wall);
                obstacles = obstacles.concat(wall);
                
                wall = new KlotskiWall(1, 7);
                wall.snapToGridPoint(4, -1);
                scene.add(wall);
                obstacles = obstacles.concat(wall);
                
                wall = new KlotskiWall(1, 1);
                wall.snapToGridPoint(0, 5);
                scene.add(wall);
                obstacles = obstacles.concat(wall);
                
                wall = new KlotskiWall(1, 1);
                wall.snapToGridPoint(3, 5);
                scene.add(wall);
                obstacles = obstacles.concat(wall);
                
                // Mouse events
				document.addEventListener('mousedown', mouseClicked, false);
            }
            
            
            /**
             Update loop
             */
            function tick() {
                requestAnimationFrame(tick);
                
                renderer.render(scene, camera)
                
                for (var i = 0; i < blocks.length; i++) {
                    blocks[i].step();
                }
            }
            
            
            /*-------------------------------
             --------| Mouse Events |--------
             -------------------------------*
             /**
             When the mouse is clicked, XXX
             */
			function mouseClicked(event) {
				event.preventDefault();
                var mouseX = event.clientX;
                var mouseY = event.clientY;
                
                // Add listeners for future mouse events
                document.addEventListener('mousemove', mouseMoved, false);
                document.addEventListener('mouseup', mouseReleased, false);
                
                for (var i = 0; i < blocks.length; i++) {
                    
                    var hit = MouseInterface.getMouseHit(blocks, mouseX, mouseY);
                    if (hit) {
                        selected = hit.object.parent;
                        selected.setSelected(true);
                        
                        // ...
                        hit = MouseInterface.getMouseHit([floor], mouseX, mouseY);
                        
                        if (hit) {
                            mouseCubeOffset.subVectors(hit.point, selected.position);
                        }
                    } return;
                }
            }
            
            
            /**
             Called whenever the mouse is moved.
             */
            function mouseMoved(event) {
                // If a cube is selected, update its target position
                if (selected) {
                    var mouseX = event.clientX;
                    var mouseY = event.clientY;
                    // Find where the mouse intersects the floor
                    var hit = MouseInterface.getMouseHit([floor],mouseX, mouseY);
                    if (hit) {
                        var target = new THREE.Vector3();
                        target.subVectors(hit.point, mouseCubeOffset);
                        selected.updateTargetPosition(target);
                    }
                }
            }
            
            
            /**
             This is called when the left mouse button is released
             */
            function mouseReleased(event) {
                // If a cube is selected, deselect it.
                if (selected) {
                    selected.setSelected(false);
                    selected.
                    selected = null;
                }
                // Stop listening for mousemove move and mouseup events
                // until the mouse has been clicked again
                document.removeEventListener('mousemove', mouseMoved, false);
                document.removeEventListener('mouseup', mouseReleased, false);
            }
            
            </script>
    </body>
</html>
