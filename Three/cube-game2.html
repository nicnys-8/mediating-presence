<!doctype html>
<html lang="en">
    <head>
        <title>Cube Game</title>
        <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                
                </head>
    <body style="overflow:hidden; margin:0px">
        
        <div id="message"></div>
        
        <script src="../js/lib/Three.js"></script>
        <script src="../js/moving-cube.js"></script>
        
        <script>
            
            // Camera constants
            const VIEW_ANGLE = 45;
            
            const SCREEN_WIDTH = window.innerWidth;
            const SCREEN_HEIGHT = window.innerHeight;
            
            const ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
            const NEAR = 0.1;
            const FAR = 20000;
            
            var container, scene, camera, renderer, controls;
            
            var mouseXOnMouseDown = 0;
            var selectedCube = null;
            
            var floor;
            
            var movingCubes = [];
            var obstacles = [];
            
            var mouseCubeOffset = new THREE.Vector3(0, 0, 0);
            
            init();
            tick();
            
            /**
             Set up the scene
             */
            function init() {
                // Scene
                scene = new THREE.Scene();
                
                // Camera
                camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
                scene.add(camera);
                camera.position.set(0,400,400);
                camera.lookAt(scene.position);
                
                // Renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
                container = document.createElement('div');
                document.body.appendChild(container);
                container.appendChild(renderer.domElement);
                
                // Events -- OY!!!! Find out exactly what this does later!
                //THREEx.WindowResize(renderer, camera);
                
                // Light
                var light = new THREE.PointLight(0xffffff);
                light.position.set(0,250,0);
                scene.add(light);
                
                // Floor
                var floorMaterial = new THREE.MeshLambertMaterial();
                var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
                floor = new THREE.Mesh(floorGeometry, floorMaterial);
                
                
                floor.rotation.x -= Math.PI / 2; // Rotate the floor correctly
                floor.position.y = -0.5; // Move a tiny bit to prevent flickering
                
                floor.doubleSided = true;
                scene.add(floor);
                
                
                
                ////
                
                var sphere1 = new Sphere();
                var sphere2 = new Sphere();
                console.log("Before:");
                console.log(sphere1.size);
                console.log(sphere2.size);
                
                sphere1.double();
                
                console.log("After:");
                console.log(sphere1.size);
                console.log(sphere2.size);
                
                
                
                /////
                
                
                // Cube
                var movingCube1 =  new MovingCube();
                
                var movingCube1 = new MovingCube();
                movingCube1.setPosition(-300, 25, 0);
                movingCube1.setObstacles(obstacles);
                scene.add(movingCube1);
                movingCubes.push(movingCube1);
                                
                var movingCube2 = new MovingCube();
                movingCube2.setPosition(-100, 25, 0);
                movingCube2.setObstacles(obstacles);
                scene.add(movingCube2);
                movingCubes.push(movingCube2);
                
                var movingCube3 = new MovingCube();
                movingCube3.setPosition(-200, 25, 0);
                movingCube3.setObstacles(obstacles);
                scene.add(movingCube3);
                movingCubes.push(movingCube3);
                
                
                
                // Obstacles
                var geometry = new THREE.CubeGeometry(CUBE_SIDE, CUBE_SIDE, CUBE_SIDE);
                var material = new THREE.MeshLambertMaterial();
                material.color.setHex(0x0000ff);
                
                obstacle1 =  new THREE.Mesh(geometry, material);
                obstacle1.position.set(200, 25, 102);
                scene.add(obstacle1);
                obstacles.push(obstacle1);
                
                obstacle2 =  new THREE.Mesh(geometry, material);
                obstacle2.position.set(200, 25, 0);
                scene.add(obstacle2);
                obstacles.push(obstacle2);
                
                // Mouse events
				document.addEventListener('mousedown', mouseClicked, false);
            }
            
            
            /**
             Update loop
             */
            function tick() {
                requestAnimationFrame(tick);
                
                renderer.render(scene, camera)
                
                if (selectedCube) {
                    selectedCube.xStep(1);
                    selectedCube.zStep(1);
                }
            }
            
            
            /*-------------------------------
             --------| Mouse Events |--------
             -------------------------------*
             
             /**
             When the mouse is clicked, XXX
             */
			function mouseClicked(event) {
				event.preventDefault();
                // Add listeners for future mouse events
                document.addEventListener('mousemove', mouseMoved, false);
                document.addEventListener('mouseup', mouseReleased, false);
                
                if (selectedCube) {
                    selectedCube.setSelected(false);
                } else {
                    for (var i = 0; i < movingCubes.length; i++) {
                        var meshes = movingCubes[i].meshes;
                        var hitPoint;
                        for (var j = 0; j < meshes.length; j++) {
                            var mesh = meshes[j];
                            hitPoint = getMouseHitPoint(mesh);
                            if (hitPoint) {
                                selectedCube = movingCubes[i];
                                selectedCube.setSelected(true);
                                return;
                            }
                        }
                    }
                    
                    
                    if (selectedCube) {
                        selectedCube.setSelected(true);
                        var intersectionPoint = getMouseHitPoint([selectedCube]);
                        mouseCubeOffset.subVectors(intersectionPoint, selectedCube.position);
                        selectedCube.setTargetPosition(intersectionPoint.sub(mouseCubeOffset));
                    }
                }
            }
            
            
            /**
             When the mouse is moved, XXX
             */
            function mouseMoved(event) {
                if (selectedCube) {
                    var intersectionPoint = getMouseHitPoint(floor);
                    if (intersectionPoint) {
                        selectedCube.setTargetPosition(intersectionPoint.sub(mouseCubeOffset));
                    }
                }
            }
            
            
            /**
             This is called when the left mouse button is released
             */
            function mouseReleased(event) {
                if (selectedCube) {
                    selectedCube.setSelected(false);
                    selectedCube = null;
                }
                document.removeEventListener('mousemove', mouseMoved, false);
                document.removeEventListener('mouseup', mouseReleased, false);
            }
            
            
            /**
             Get current mouse position as a 3D vector
             */
            function getMousePosition() {
                var mouse3D = new THREE.Vector3();
                mouse3D.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse3D.y = -(event.clientY / window.innerHeight) * 2 + 1;
                mouse3D.z = 0.5;
                return mouse3D;
            }
            
            /**
             
             */
            function getHitObject(objects) {
                var mousePosition = getMousePosition();
                var projector = new THREE.Projector();
                projector.unprojectVector(mousePosition, camera);
                
                // Set up the normal vector pointing from the
                // camera to the target position
                var v = new THREE.Vector3();
                v.subVectors(mousePosition, camera.position);
                v.normalize();
                
                var ray = new THREE.Raycaster(camera.position, v);
                var intersected = ray.intersectObjects(objects, false);
                if (intersected[0]) { // Check if the mouse is on the floor
                    console.log(intersected[0].object);
                    return intersected[0].object;
                }
            }
            
            /**
             Returns the intersection point on the closest object hit by
             the mouse
             */
            function getMouseHitPoint(object) {
                var mousePosition = getMousePosition();
                var projector = new THREE.Projector();
                projector.unprojectVector(mousePosition, camera);
                
                // Set up the normal vector pointing from the
                // camera to the target position
                var v = new THREE.Vector3();
                v.subVectors(mousePosition, camera.position);
                v.normalize();
                
                var ray = new THREE.Raycaster(camera.position, v);
                
                var intersected = ray.intersectObjects([object], false);
                if (intersected[0]) { // Check if the mouse is on the floor
                    return intersected[0].point;
                }
            }
            
            
            
            
            </script>
        
    </body>
</html>
