<!doctype html>
<html lang="en">
    <head>
        <title>Moving Cube</title>
        <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                
                </head>
    <body style="overflow:hidden; margin:0px">
        
        <div id="message"></div>
        
        <script src="../js/lib/THREEx.Three.js"></script>
        <script src="../js/lib/THREEx.FullScreen.js"></script>
        <script src="../js/lib/THREEx.WindowResize.js"></script>
        <script src="../js/lib/THREEx.Projector.js"></script>
        <script src="../js/lib/THREEx.Projector.js"></script>
        
        <script>
            
            // Camera constants
            const VIEW_ANGLE = 45;
            
            const SCREEN_WIDTH = window.innerWidth;
            const SCREEN_HEIGHT = window.innerHeight;
            
            const ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
            const NEAR = 0.1;
            const FAR = 20000;
            
            // Other constants
            const CUBE_SIDE = 50;
            
            var picked = false;
            
            var floor;
            var container, scene, camera, renderer, controls;
            
            var mouseXOnMouseDown = 0;
            var MovingCube;
            
            init();
            tick();
            
            function init() {
                // Scene
                scene = new THREE.Scene();
                
                // Camera
                camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
                scene.add(camera);
                camera.position.set(0,150,400);
                camera.lookAt(scene.position);
                
                // Renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
                container = document.createElement('div');
                document.body.appendChild(container);
                container.appendChild(renderer.domElement);
                
                // Events -- Find out exactly what this does later!
                THREEx.WindowResize(renderer, camera);
                
                // Light
                var light = new THREE.PointLight(0xffffff);
                light.position.set(0,250,0);
                scene.add(light);
                
                // Floor
                var floorMaterial = new THREE.MeshLambertMaterial();
                var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
                floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.5; // Move a tiny bit to prevent flickering
                floor.doubleSided = true;
                scene.add(floor);
                
                // Cube
				var geometry = new THREE.CubeGeometry(CUBE_SIDE, CUBE_SIDE, CUBE_SIDE);
				var material = new THREE.MeshLambertMaterial();
                material.color.setHex(0xff0000);
                movingCube =  new THREE.Mesh(geometry, material);
                movingCube.position.set(0, 25.1, 0);
                scene.add( movingCube );
                
                // Mouse events
				document.addEventListener('mousedown', mouseClicked, false);
            }
            
            /**
             This is called whenever the mouse is clicked
             */
			function mouseClicked(event) {
				event.preventDefault();
                
                var mouse3D = new THREE.Vector3();
                mouse3D.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse3D.y = -(event.clientY / window.innerHeight) * 2 + 1;
                mouse3D.z = 0.5;
                
                var pr = new THREE.Projector();
                
                pr.unprojectVector(mouse3D, camera);
                
                var ray = new THREE.Ray(camera.position, mouse3D.subSelf(camera.position).normalize());
                
                var intersectFloor = ray.intersectObject(floor);
                
                if (intersectFloor[0]) {
                    var intersectionPoint = intersectFloor[0].point;
                    if (picked) {
                        movingCube.position.set(intersectionPoint.x,
                                                intersectionPoint.y + CUBE_SIDE / 2,
                                                intersectionPoint.z);
                        movingCube.material.color.setHex(0xff0000);
                        picked = false;
                    }
                }
                
                var intersectsCube = ray.intersectObject(movingCube);
                if (intersectsCube[0]) {
                    if (!picked) picked = true;
                    movingCube.material.color.setHex(0x00ff00);
                }
			}
            
            
            /**
             Update loop
             */
            function tick() {
                requestAnimationFrame(tick);
                renderer.render(scene, camera)
                //update();
            }
            
            </script>
        
    </body>
</html>
