<!doctype html>
<html lang="en">
    <head>
        <title>Three.js -- Template</title>
        <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                <style>
                    body
                    {
                        font-family: Monospace;
                        font-weight: bold;
                        background-color: #ccccff;
                        margin: 0px;
                        overflow: hidden;
                    }
                    </style>
                </head>
    <body>
        
        <div id="message"></div>
        
        <script src="../js/THREEx.Three.js"></script>
        <script src="../js/THREEx.KeyboardState.js"></script>
        <script src="../js/THREEx.FullScreen.js"></script>
        <script src="../js/THREEx.WindowResize.js"></script>
        <script src="../js/THREEx.Projector.js"></script>
        
        <script>
            /* 	Three.js  */
            
            // MAIN
            
            //if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            
            const CUBE_SIDE = 50;
            
            var floor;
            
            var container, scene, camera, renderer, controls;
            var keyboard;
            var clock;
            
            var mouseXOnMouseDown = 0;
            var MovingCube;
            var SCREEN_WIDTH;
            var SCREEN_HEIGHT;
            
            init();
            tick();
            
            function init() {
                // Scene
                scene = new THREE.Scene();
                
                // Keyboard
                keyboard = new THREEx.KeyboardState();
                
                // Clock
                clock = new THREE.Clock();
                
                // create a point light
                var pointLight = new THREE.PointLight( 0xFFFFFF );
                
                // set its position
                pointLight.position.x = 10;
                pointLight.position.y = 50;
                pointLight.position.z = 130;
                
                // add to the scene
                scene.add(pointLight);
                
                // CAMERA
                SCREEN_WIDTH = window.innerWidth;
                SCREEN_HEIGHT = window.innerHeight;
                
                var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
                camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
                scene.add(camera);
                camera.position.set(0,150,400);
                camera.lookAt(scene.position);
                
                // Renderer
                renderer = new THREE.WebGLRenderer( {antialias:true} );
                renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
                container = document.createElement( 'div' );
                document.body.appendChild( container );
                container.appendChild( renderer.domElement );
                
                // Events -- Find out exactly what these do later!
                THREEx.WindowResize(renderer, camera);
                THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
                
                // Controls
                controls = new THREE.TrackballControls( camera );
                
                // Light
                var light = new THREE.PointLight(0xffffff);
                light.position.set(0,250,0);
                scene.add(light);
                
                // Floor
                var floorTexture = new THREE.ImageUtils.loadTexture( '../images/starSky.png' );
                floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
                floorTexture.repeat.set( 10, 10 );
                var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture } );
                var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
                floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.5; //
                floor.doubleSided = true;
                scene.add(floor);
                
                // Cube
				var geometry = new THREE.CubeGeometry(CUBE_SIDE, CUBE_SIDE, CUBE_SIDE);
                
                // Cube colors
                geometry.faces[0].color.setHex(0xff0000);
                geometry.faces[1].color.setHex(0x00ff00);
                geometry.faces[2].color.setHex(0x00ff00);
                geometry.faces[3].color.setHex(0x00ff00);
                geometry.faces[4].color.setHex(0x0000ff);
                geometry.faces[5].color.setHex(0xffff00);
                
				var material = new THREE.MeshLambertMaterial({vertexColors: THREE.FaceColors});
                
                movingCube =  new THREE.Mesh(geometry, material);
                movingCube.position.set(0, 25.1, 0);
                scene.add( movingCube );
                
                // Mouse events
				document.addEventListener('mousedown', onDocumentMouseDown, false);
            }
            
            
			function onDocumentMouseDown(event) {
				event.preventDefault();
				
                
                var mouse3D = new THREE.Vector3();
                mouse3D.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse3D.y = -(event.clientY / window.innerHeight) * 2 + 1;
                mouse3D.z = 0.5;
                
                var pr = new THREE.Projector();
                
                pr.unprojectVector(mouse3D, camera);
                
                var ray = new THREE.Ray(camera.position, mouse3D.subSelf(camera.position).normalize());

                var intersects = ray.intersectObject(floor);
                
                //mouseXOnMouseDown = event.clientX - SCREEN_WIDTH / 2;
                /*movingCube.position.set(mouseXOnMouseDown,
                                        movingCube.position.y,
                                        movingCube.position.z);
                 */
                console.log(intersects[0].point.x);
                
                //movingCube.position.set(intersects[0].point);

                movingCube.position.set(intersects[0].point.x,
                                        intersects[0].point.y + CUBE_SIDE / 2,
                                        intersects[0].point.z);
                
                // console.log("Intersects at: " + intersects.position.x);
                // console.log(movingCube.position);
			}
            
            
            function tick() {
                requestAnimationFrame(tick);
                
                
                render();
                update();
            }
            
            
            function update() {
                var delta = clock.getDelta(); // seconds.
                var moveDistance = 200 * delta; // 200 pixels per second
                var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second
                
                // local coordinates
                
                // move forwards / backwards
                if ( keyboard.pressed("W") )
                movingCube.translateZ( -moveDistance );
                if ( keyboard.pressed("S") )
                movingCube.translateZ(  moveDistance );
                // rotate left/right
                if ( keyboard.pressed("A") )
                {
                    var rotation_matrix = new THREE.Matrix4().makeRotationY(rotateAngle);
                    movingCube.matrix.multiplySelf(rotation_matrix);
                    movingCube.rotation.getRotationFromMatrix(movingCube.matrix);
                }
                if ( keyboard.pressed("D") )
                {
                    var rotation_matrix = new THREE.Matrix4().makeRotationY(-rotateAngle);
                    movingCube.matrix.multiplySelf(rotation_matrix);
                    movingCube.rotation.getRotationFromMatrix(movingCube.matrix);
                }
                if ( keyboard.pressed("Q") )
                movingCube.translateX( -moveDistance );
                if ( keyboard.pressed("E") )
                movingCube.translateX(  moveDistance );
                // rotate up/down
                if ( keyboard.pressed("R") )
                {
                    var rotation_matrix = new THREE.Matrix4().makeRotationX(rotateAngle);
                    movingCube.matrix.multiplySelf(rotation_matrix);
                    movingCube.rotation.getRotationFromMatrix(movingCube.matrix);
                }
                if ( keyboard.pressed("F") )
                {
                    var rotation_matrix = new THREE.Matrix4().makeRotationX(-rotateAngle);
                    movingCube.matrix.multiplySelf(rotation_matrix);
                    movingCube.rotation.getRotationFromMatrix(movingCube.matrix);
                }
                
                
                // global coordinates
                if ( keyboard.pressed("left") )
                movingCube.position.x -= moveDistance;
                if ( keyboard.pressed("right") )
                movingCube.position.x += moveDistance;
                if ( keyboard.pressed("up") )
                movingCube.position.z -= moveDistance;
                if ( keyboard.pressed("down") )
                movingCube.position.z += moveDistance;
                
                controls.update();
            }
            
            function render()
            {
                renderer.render(scene, camera);
            }
            
            </script>
        
    </body>
</html>
