
<!-- saved from url=(0052)http://learningwebgl.com/lessons/lesson02/index.html -->

<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
	
	<title>Point Cloud Rendering Test</title>
	
    <script type="text/javascript" src="js/mediaext.js"></script>
	<script type="text/javascript" src="js/lib/webgl-utils.js"></script>
	<script type="text/javascript" src="js/lib/glMatrix-0.9.5.min.js"></script>
    
	<style type="text/css">
		body {
			font-family:monospace;
			text-align:center;
		}
        #dropbox {
			border:10px dashed #ccc;
            width:300px;
            height:300px;
            margin:20px auto;
		}
        #dropbox.hover {
            border:10px dashed #333;
		}
		#status {
			margin-top:140px;
		}
		#progressBar {
			margin:1em;
			padding:3px;
			border:1px solid #000;
			font-size:2em;
			clear:both;
			opacity:0;
			-moz-transition:opacity 1s linear;
			-o-transition:opacity 1s linear;
			-webkit-transition:opacity 1s linear;
		}
		#progressBar.loading {
			opacity:1.0;
		}
		#percentBar {
			background-color:#99ccff;
			height:auto;
			width:0;
		}
    </style>
	
	<script id="shader-fs" type="x-shader/x-fragment">
		precision mediump float;
		varying vec4 vColor;
		void main(void) {
			gl_FragColor = vColor;
		}
	</script>
	
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		attribute vec4 aVertexColor;
		
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		
		varying vec4 vColor;
		
		void main(void) {
			vec4 pos = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			gl_PointSize = 20.0 / pos.z;
            gl_Position = pos;
			vColor = aVertexColor;
		}
    </script>
	
	<script type="text/javascript">
		
		PlyParse = {};
		
		// Simple .ply parser for ascii input with assumed line format x y z nx ny nz r g b
		// (this is just a test, I will make this more dynamic and error tolerant)
		PlyParse.parse = function(inputStr) {
			
			var split = inputStr.split("\n");
			var index = 0;
			var line = "";
		
			while (index < split.length && line !== "end_header") {
				line = split[index++];
			}

			var pos = new Array((split.length - index) * 3);
			var rgb = new Array((split.length - index) * 4);
			
			for (var i = index + 1; i < split.length; i++) {
				
				line = split[i];
				
				var values = line.split(" ");
				
				pos[i * 3 + 0] = parseFloat(values[0]);
				pos[i * 3 + 1] = parseFloat(values[1]);
				pos[i * 3 + 2] = parseFloat(values[2]);
				
				// parse normals
				
				rgb[i * 4 + 0] = parseFloat(values[6]) / 255.0;
				rgb[i * 4 + 1] = parseFloat(values[7]) / 255.0;
				rgb[i * 4 + 2] = parseFloat(values[8]) / 255.0;
				rgb[i * 4 + 3] = 1.0;
			}
			
			return [pos, rgb];
		};
	</script>
	
	<script type="text/javascript">
		
        const kWidth = 640, kHeight = 480;
        var glCanvas;
		var gl, prog;
		
		function initShaders() {
            
			var vsStr = document.getElementById("shader-vs").text;
            var fsStr = document.getElementById("shader-fs").text;
            prog = WebGLUtils.createProgram(gl, vsStr, fsStr);
            
            gl.useProgram(prog);
			
			prog.vertexPositionAttribute = gl.getAttribLocation(prog, "aVertexPosition");
			gl.enableVertexAttribArray(prog.vertexPositionAttribute);
			
			prog.vertexColorAttribute = gl.getAttribLocation(prog, "aVertexColor");
			gl.enableVertexAttribArray(prog.vertexColorAttribute);
			
			prog.pMatrixUniform = gl.getUniformLocation(prog, "uPMatrix");
			prog.mvMatrixUniform = gl.getUniformLocation(prog, "uMVMatrix");
		}
		
		
		var mvMatrix = mat4.create();
		var pMatrix = mat4.create();
		
		function setMatrixUniforms() {
			gl.uniformMatrix4fv(prog.pMatrixUniform, false, pMatrix);
			gl.uniformMatrix4fv(prog.mvMatrixUniform, false, mvMatrix);
		}
		
		var triangleVertexPositionBuffer;
		var triangleVertexColorBuffer;
		var squareVertexPositionBuffer;
		var squareVertexColorBuffer;
		
		function initBuffers() {
			triangleVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
			var vertices = [
							0.0,  1.0,  0.0,
							-1.0, -1.0,  0.0,
							1.0, -1.0,  0.0
							];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			triangleVertexPositionBuffer.itemSize = 3;
			triangleVertexPositionBuffer.numItems = 3;
			
			triangleVertexColorBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
			var colors = [
						  1.0, 0.0, 0.0, 1.0,
						  0.0, 1.0, 0.0, 1.0,
						  0.0, 0.0, 1.0, 1.0
						  ];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
			triangleVertexColorBuffer.itemSize = 4;
			triangleVertexColorBuffer.numItems = 3;
			
			
			squareVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
			vertices = [
						1.0,  1.0,  0.0,
						-1.0,  1.0,  0.0,
						1.0, -1.0,  0.0,
						-1.0, -1.0,  0.0
						];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			squareVertexPositionBuffer.itemSize = 3;
			squareVertexPositionBuffer.numItems = 4;
			
			squareVertexColorBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
			colors = []
			for (var i=0; i < 4; i++) {
				colors = colors.concat([0.5, 0.5, 1.0, 1.0]);
			}
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
			squareVertexColorBuffer.itemSize = 4;
			squareVertexColorBuffer.numItems = 4;
		}
		
		function drawScene() {
			
            requestAnimFrame(drawScene);
            
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			
			mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
			
			mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
            
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
			gl.vertexAttribPointer(prog.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
			gl.vertexAttribPointer(prog.vertexColorAttribute, triangleVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
			setMatrixUniforms();
			gl.drawArrays(gl.POINTS, 0, triangleVertexPositionBuffer.numItems);
			
			mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
            mat4.multiply(mvMatrix, pcRotationMatrix);
            
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
			gl.vertexAttribPointer(prog.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
			gl.vertexAttribPointer(prog.vertexColorAttribute, squareVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
            
			setMatrixUniforms();
			gl.drawArrays(gl.POINTS, 0, squareVertexPositionBuffer.numItems);
		}
		
		
		
		function init() {
            
            glCanvas = MediaExt.createCanvas(kWidth, kHeight);
            gl = WebGLUtils.setupWebGL(glCanvas);
            gl.viewportWidth = glCanvas.width;
            gl.viewportHeight = glCanvas.height;
            document.getElementById("container").appendChild(glCanvas);
            
            initShaders();
			initBuffers();
			
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.enable(gl.DEPTH_TEST);
			
            glCanvas.onmousedown = handleMouseDown;
            document.onmouseup = handleMouseUp;
            document.onmousemove = handleMouseMove;
            
			drawScene();
            
            // **********************
            // Drag and drop with File API
            var dropbox = document.getElementById("dropbox"),
				state = document.getElementById("status");
            
            if (typeof window.FileReader === "undefined") {
                state.className = "fail";
                state.innerHTML = "File API unavailable, change browser!!!! :)";
            } else {
                state.className = "success";
            }
            
            dropbox.ondragenter = function () {
                this.className = "hover";
                return false;
            };
            dropbox.ondragleave = function () {
                this.className = "";
                return false;
            };
			dropbox.ondragover = function () { return false; };
			dropbox.ondragend = function () { return false; };
			
            dropbox.ondrop = function (e) {
				
                this.className = "";
                
				e.preventDefault();
                
                var file = e.dataTransfer.files[0],
                    reader = new FileReader();
                
                var splitName = file.name.split(".");
                if (splitName.length == 2) {
                    var extension = splitName[1];
                    if (extension == "ply") {
                        // Parse the .ply file
                    }
                }
                // or maybe:
                if (file.name.substring(file.name.length - 4) === ".ply") {
                    // Parse the .ply file
                }
                
				var progress = document.getElementById("percentBar");
				
				reader.onerror = errorHandler;
				reader.onprogress = updateProgress;
				reader.onabort = function(e) {
					alert("File read cancelled");
				};
				reader.onloadstart = function(e) {
					document.getElementById("progressBar").className = "loading";
				};
                reader.onload = function (event) {
                    console.log("Length of string: " + event.target.result.length);
                    // console.log(event.target);
                    // dropbox.style.background = 'url(' + event.target.result + ') no-repeat center';
					
					// Ensure that the progress bar displays 100% at the end.
					progress.style.width = '100%';
					progress.textContent = '100%';
					setTimeout("document.getElementById('progressBar').className='';", 2000);
					
					var points = PlyParse.parse(event.target.result);
					var pos = points[0];
					var rgb = points[1];
					
					gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
					squareVertexPositionBuffer.itemSize = 3;
					squareVertexPositionBuffer.numItems = pos.length / 3;
					
					gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rgb), gl.STATIC_DRAW);
					squareVertexColorBuffer.itemSize = 4;
					squareVertexColorBuffer.numItems = rgb.length / 4;
                };
				
                console.log(file);
                // reader.readAsDataURL(file);
                reader.readAsText(file);
                
                return false;
            };
            // **********************
		}
		
        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }
        
		function updateProgress(evt) {
			
			var progress = document.getElementById("percentBar");
			
			// evt is an ProgressEvent.
			if (evt.lengthComputable) {
				var percentLoaded = Math.round((evt.loaded / evt.total) * 100);
				// Increase the progress bar length.
				if (percentLoaded < 100) {
					progress.style.width = percentLoaded + '%';
					progress.textContent = percentLoaded + '%';
				}
			}
		}
		
		function errorHandler(evt) {
			switch(evt.target.error.code) {
				case evt.target.error.NOT_FOUND_ERR:
				alert('File Not Found!');
				break;
				case evt.target.error.NOT_READABLE_ERR:
				alert('File is not readable');
				break;
				case evt.target.error.ABORT_ERR:
				break; // noop
				default:
				alert('An error occurred reading this file.');
			};
		}
		
        var mouseDown = false;
        var lastMouseX = null;
        var lastMouseY = null;
        
        var pcRotationMatrix = mat4.create();
        mat4.identity(pcRotationMatrix);
        
        function handleMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function handleMouseUp(event) {
            mouseDown = false;
        }
        
        function handleMouseMove(event) {
            
            if (!mouseDown) {
                return;
            }
            var newX = event.clientX;
            var newY = event.clientY;
            
            var deltaX = newX - lastMouseX;
            var newRotationMatrix = mat4.create();
            mat4.identity(newRotationMatrix);
            mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
            
            var deltaY = newY - lastMouseY;
            mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
            
            mat4.multiply(newRotationMatrix, pcRotationMatrix, pcRotationMatrix);
            
            lastMouseX = newX
            lastMouseY = newY;
        }
        
		</script>
	
	
</head>
	
	<body onload="init();">
       
            <h1>Point Cloud Drag and Drop</h1>
            <div id="container">
                <div id="dropbox">
                    <p id="status">Drop a .ply file here!</p>
					<div id="progressBar">
						<div id="percentBar">0%</div>
					</div>
                </div>
            </div>
       
	</body>

</html>